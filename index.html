<!DOCTYPE html>
<html>
    <head>
        <title>Recursion schemes from the ground up</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link rel="stylesheet" type="text/css" href="css/style.css"/>
    </head>
    <body>
        <textarea id="source">
class: center, middle

# Recursion schemes from the ground up

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

---

class: center, middle

# Recursive Data Structures

---

## `List`

```scala
sealed trait List

case class Cons(
  head: Int,
  tail: List
) extends List

case object Nil extends List
```

```scala
val ints: List = Cons(1, Cons(2, Cons(3, Nil)))
```

---

class: center, middle

# Structural Recursion

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints)
// res0: Int = 6
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + mkString(tail)
  }
```

```scala
mkString(ints)
// res1: String = 1 :: 2 :: 3 :: nil
```

---

## Generalising structural recursion

```scala
def mkString(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + mkString(tail)
  }
```

---

## Generalising structural recursion

```scala
def recurse(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + recurse(tail)
  }
```

Rename to `recurse` because we're doing something generic.

---

## Generalising structural recursion

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => head + " :: " + recurse(base, tail)
  }
```

Abstract over the base case.

---

## Generalising structural recursion

```scala
def recurse(
  base  : String,
  step  : (Int, String) => String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, step, tail))
  }
```

Abstract over the step-case.

---

## Generalising structural recursion

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A =
  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, step, tail))
  }
```

Make things parametric, because we can work with more than just ints as output.

---

## Generalising structural recursion

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {

  def loop(curr: List): A = curr match {
    case Nil              => base
    case Cons(head, tail) => step(head, loop(tail))
  }

  loop(values)
}
```

Too many parameters, make more readable.

---

## Generalising structural recursion

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
)(
  values: List
): A = {

  def loop(curr: List): A = curr match {
    case Nil              => base
    case Cons(head, tail) => step(head, loop(tail))
  }

  loop(values)
}
```

Curry, because we'll be wanting to express `length` etc as partial application.

---

## Fold

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
)(
  values: List
): A = {

  def loop(curr: List): A = curr match {
    case Nil              => base
    case Cons(head, tail) => step(head, loop(tail))
  }

  loop(values)
}
```

Rename to fold because that's what it's called.

---

## `product` as a `fold`

```scala
val product: List => Int =
  fold(
    base = 1,
    step = (head: Int, tailProduct: Int) => head * tailProduct
  )
```

```scala
product(ints)
// res2: Int = 6
```

---

## `mkString` as a `fold`

```scala
val mkString: List => String =
  fold(
    base = "nil",
    step = (head: Int, tailStr: String) => head + " :: " + tailStr
  )
```

```scala
mkString(ints)
// res3: String = 1 :: 2 :: 3 :: nil
```

---

## Key takeaways

Structural recursion is:
* providing an implementation for the smallest possible case (`base`).
* providing an implementation for larger cases that rely on smaller cases (`step`).

For cons lists, this can be generalised as `fold`.

---

class: center, middle

# Generalised structural recursion

---

## Generalising folds

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
)(
  values: List
): A = {

  def loop(curr: List): A = curr match {
    case Nil              => base
    case Cons(head, tail) => step(head, loop(tail))
  }

  loop(values)
}
```

---

## Generalising folds

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A = curr match {
    case Nil              => base
    case Cons(head, tail) => step(head, loop(tail))
  }

  loop
}
```

---

## Generalising folds

TODO: diagram explaining ListF + code for `projectList`.

---

## List projection

```scala
val projectList: List => Option[(Int, List)] =
  _ match {
    case Nil              => None
    case Cons(head, tail) => Some((head, tail))
  }
```
---

## Generalising folds

```scala
def fold[A](
  base   : A,
  step   : (Int, A) => A
): List => A = {

  def loop(curr: List): A = projectList(curr) match {
    case None               => base
    case Some((head, tail)) => step(head, loop(tail))
  }

  loop
}
```

We want to forget about list. First, let's forget about its structure

---

## Generalising folds

```scala
def fold[A](
  base   : A,
  step   : (Int, A) => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A = project(curr) match {
    case None               => base
    case Some((head, tail)) => step(head, loop(tail))
  }

  loop
}
```

---

TODO : write a function that aggregates `base` and `step` to make them into a `ListF[A] => A`.

---

## Generalising folds

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A = project(curr) match {
    case None               => op(None)
    case Some((head, tail)) => op(Some((head, loop(tail))))
  }

  loop
}
```

`base` and `step` are basically going from "nothing" to an A, or from "a head and a tail" to an A. That's an Option => A.

---

## Intermediate representation

```scala
type ListF[A] = Option[(Int, A)]
```

---

## Intermediate representation

```scala
val projectList: List => ListF[List] =
  _ match {
    case Nil              => None
    case Cons(head, tail) => Some((head, tail))
  }
```

---

## Intermediate representation

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A = project(curr) match {
    case None               => op(None)
    case Some((head, tail)) => op(Some((head, loop(tail))))
  }

  loop
}
```

---

## Generalising folds

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A = op(project(curr) match {
    case None               => None
    case Some((head, tail)) => Some((head, loop(tail)))
  })

  loop
}
```

`op` being applied in both branches of the pattern match means we can extract it and apply it to the result

---

## Generalising folds

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A = op(recurse(project(curr)))

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    }

  loop
}
```

Let's extract that pattern match so we can work with it.
It's the part where we recurse.

---

## Generalising folds

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A = op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, f(tail)))
    }

  loop
}
```

Let's make it even more familiar...

---

## Functor

```scala
trait Functor[F[_]] {
  def map[A, B](f: A => B)(fa: F[A]): F[B]
}
```

---

## Functor

```scala
implicit class FunctorOps[F[_], A](value: F[A]) {
  def fmap[B](f: A => B)(implicit func: Functor[F]): F[B] =
    func.map(f)(value)
}
```

---

## Functor

```scala
implicit val listFFunctor: Functor[ListF] = new Functor[ListF] {
  override def map[A, B](f: A => B)(fa: ListF[A]) = fa match {
    case None               => None
    case Some((head, tail)) => Some((head, f(tail)))
  }
}
```

---

## Using functors

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A = op(recurse(project(curr)))

  def recurse(option: ListF[List]) = option.fmap(loop)

  loop
}
```

Using `Functor`...

---

## Using functors

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A = op(project(curr).fmap(loop))

  loop
}
```

No need for `recurse` anymore...

---

## Abstracting over `ListF`

```scala
def fold[F[_]: Functor, A](
  op     : F[A] => A,
  project: List => F[List]
): List => A = {

  def loop(curr: List): A = op(project(curr).fmap(loop))

  loop
}
```

At this point, we don't need to know about `ListF` - just that it has a functor:

---

## Abstracting over `ListInt`

```scala
def fold[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A = op(project(curr).fmap(loop))

  loop
}
```

We don't need to know about `List` either:

---

## Proper names

```scala
def cata[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A = op(project(curr).fmap(loop))

  loop
}
```

This is called `cata`

---

## Proper names

```scala
def cata[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A = algebra(project(curr).fmap(loop))

  loop
}
```

And that's called an F-Algebra.

F is pattern functor.

---

## `product` as a `cata`

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case None               => 1
    case Some((head, tail)) => head * tail
  }

val product: List => Int = cata(productAlgebra, projectList)
```

```scala
product(ints)
// res4: Int = 6
```

---

## `mkString` as a `cata`

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case None               => "nil"
    case Some((head, tail)) => head + " :: " + tail
  }

val mkString: List => String = cata(mkStringAlgebra, projectList)
```

```scala
mkString(ints)
// res5: String = 1 :: 2 :: 3 :: nil
```

---

class: center, middle

# Generative Recursion

---

## Creating lists

```scala
def range(
  from: Int
): List = {
  if(from > 0) Cons(from, range(from - 1))
  else         Nil
}
```

```scala
mkString(
  range(3)
)
// res6: String = 3 :: 2 :: 1 :: nil
```

---

## Generalising `range`

```scala
def range(
  from: Int
): List = {
  if(from > 0) Cons(from, range(from - 1))
  else         Nil
}
```

---

## Generalising `range`

```scala
def recurse(
  from: Int
): List = {
  if(from > 0) Cons(from, recurse(from - 1))
  else         Nil
}
```

---

## Generalising `range`

```scala
def recurse(
  from     : Int,
  predicate: Int => Boolean
): List = {
  if(predicate(from)) Cons(from, recurse(from - 1, predicate))
  else                Nil
}
```

---

## Generalising `range`

```scala
def recurse(
  from     : Int,
  update   : Int => (Int, Int),
  predicate: Int => Boolean
): List = {
  if(predicate(from))  {
    val (state, next) = update(from)
    Cons(state, recurse(next, update, predicate))
  }
  else Nil
}
```

---

## Generalising `range`

```scala
def recurse[A](
  from     : A,
  update   : A => (Int, A),
  predicate: A => Boolean
): List = {
  if(predicate(from)) {
    val (state, next) = update(from)
    Cons(state, recurse(next, update, predicate))
  }
  else Nil
}
```

---

## Generalising `range`

```scala
def recurse[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  from    : A
): List = {
  if(predicate(from)) {
    val (state, next) = update(from)
    Cons(state, recurse(update, predicate)(next))
  }
  else Nil
}
```

---

## Generalising `range`

```scala
def recurse[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  from    : A
): List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop(from)
}
```

---

## Generalising `range`

```scala
def unfold[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  from    : A
): List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop(from)
}
```

---

## `range` as an `unfold`

```scala
val range: Int => List =
  unfold(
    update    = (a: Int) => (a, a - 1),
    predicate = (a: Int) => a > 0
  )
```

```scala
mkString(range(3))
// res7: String = 3 :: 2 :: 1 :: nil
```

---

# Generalising `unfold`

```scala
def unfold[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  start    : A
): List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop(start)
}
```

---

# Generalising `unfold`

```scala
def unfold[A](
  update   : A => (Int, A),
  predicate: A => Boolean
): A => List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop
}
```


---

# Generalising `unfold`

```scala
def unfold[A](
  update: A => Option[(Int, A)]
): A => List = {

  def loop(curr: A): List = update(curr) match {
    case Some((head, state)) => Cons(head, loop(state))
    case None                => Nil
  }

  loop
}
```

Intuitively, we want to go to `ListF` again. `update` + `predicate` really look like one.

---

# Generalising `unfold`

```scala
def unfold[A](
  update: A => Option[(Int, A)],
  embed : Option[(Int, List)] => List
): A => List = {

  def loop(curr: A): List = embed(update(curr) match {
    case Some((head, state)) => Some((head, loop(state)))
    case None                => None
  })

  loop
}
```

We want to forget about the structure of list...

---

# Generalising `unfold`

```scala
val embedList: Option[(Int, List)] => List =
  _ match {
    case Some((head, tail)) => Cons(head, tail)
    case None               => Nil
  }
```

---

# Generalising `unfold`

```scala
def unfold[A](
  update: A => ListF[A],
  embed : ListF[List] => List
): A => List = {

  def loop(curr: A): List = embed(update(curr) match {
    case Some((head, state)) => Some((head, loop(state)))
    case None                => None
  })

  loop
}
```

We have a name for that type...

---

# Generalising `unfold`

```scala
val embedList: ListF[List] => List =
  _ match {
    case Some((head, tail)) => Cons(head, tail)
    case None               => Nil
  }
```

---

# Generalising `unfold`

```scala
def unfold[A](
  update: A => ListF[A],
  embed : ListF[List] => List
): A => List = {

  def loop(curr: A): List = embed(update(curr).fmap(loop))

  loop
}
```

That looks a lot like our functor instance...

---

# Generalising `unfold`

```scala
def unfold[F[_]: Functor, A](
  update: A => F[A],
  embed : F[List] => List
): A => List = {

  def loop(curr: A): List = embed(update(curr).fmap(loop))

  loop
}
```

We don't need to know about `ListF`...

---

# Generalising `unfold`

```scala
def unfold[F[_]: Functor, A, B](
  update: A => F[A],
  embed : F[B] => B
): A => B = {

  def loop(curr: A): B = embed(update(curr).fmap(loop))

  loop
}
```

Or `List`...

---

# Anamorphism

```scala
def ana[F[_]: Functor, A, B](
  update: A => F[A],
  embed : F[B] => B
): A => B = {

  def loop(curr: A): B = embed(update(curr).fmap(loop))

  loop
}
```

This is named ana

---

# Anamorphism

```scala
def ana[F[_]: Functor, A, B](
  coAlgebra: A => F[A],
  embed    : F[B] => B
): A => B = {

  def loop(curr: A): B = embed(coAlgebra(curr).fmap(loop))

  loop
}
```

And this is named co-algebra

---

## `range` as an `ana`

```scala
val rangeCoAlgebra: Int => ListF[Int] = i => {
  if(i > 0) Some((i, i - 1))
  else      None
}

val range: Int => List = ana(rangeCoAlgebra, embedList)
```

```scala
mkString(range(3))
// res8: String = 3 :: 2 :: 1 :: nil
```

---

class: center, middle

# What about non-`List`?

---

## Tree

```scala
sealed trait Tree

case class Node(
  left: Tree,
  value: Int,
  right: Tree
) extends Tree

case object Leaf extends Tree
```

```scala
val intTree = Node(
  Node(
    Node(Leaf, 1, Leaf),
    2,
    Node(Leaf, 3, Leaf)
  ),
  4,
  Leaf
)
// intTree: Node = Node(Node(Node(Leaf,1,Leaf),2,Node(Leaf,3,Leaf)),4,Leaf)
```

---

## Pattern functor

```scala
sealed trait TreeF[+A]

case class NodeF[A](
  left: A,
  value: Int,
  right: A
) extends TreeF[A]

case object LeafF extends TreeF[Nothing]
```

---

## Projection

```scala
def projectTree: Tree => TreeF[Tree] =
  _ match {
    case Leaf          => LeafF
    case Node(l, v ,r) => NodeF(l, v, r)
  }
```

---

## Embedding

```scala
def embedTree: TreeF[Tree] => Tree =
  _ match {
    case LeafF          => Leaf
    case NodeF(l, v, r) => Node(l, v, r)
  }

```

---

## Functor instance

```scala
implicit val treeFFunctor: Functor[TreeF] = new Functor[TreeF] {
  override def map[A, B](f: A => B)(tree: TreeF[A]) = tree match {
    case LeafF          => LeafF
    case NodeF(l, v, r) => NodeF(f(l), v, f(r))
  }
}
```

---

## Tree depth

```scala
val depthAlgebra: TreeF[Int] => Int =
  _ match {
    case LeafF                           => 0
    case NodeF(leftDepth, _, rightDepth) => math.max(
      leftDepth + 1,
      rightDepth + 1
    )
  }

val depth: Tree => Int = cata(depthAlgebra, projectTree)
```

```scala
depth(intTree)
// res9: Int = 3
```

---

## Key takeaways

* `cata` works just fine with `Tree`.
* it involves a lot of busywork though...

---

class: center, middle

# Reducing the boilerplate

---

## `List` in terms of `ListF`

```scala
type Foo = ListF[???]
```

---

## `List` in terms of `ListF`

```scala
type Foo = ListF[ListF[???]]
```

---

## `List` in terms of `ListF`

```scala
type Foo = ListF[Foo]
```


---

## `List` in terms of `ListF`

```scala
type Foo = ListF[Foo]
//        type Foo = ListF[Foo]
//                         ^
// On line 2: error: illegal cyclic reference involving type Foo
```

---

## `List` in terms of `ListF`

```scala
case class Foo(value: ListF[Foo])
```

---

## `List` in terms of `ListF`

```scala
case class Foo[F[_]](value: F[Foo[F]])
```

---

## `Fix`

```scala
case class Fix[F[_]](value: F[Fix[F]])
```

---

## `List` in terms of `Fix`


```scala
type FixedList = Fix[ListF]
```

---

## Projecting `Fix`

```scala
def projectFixedList(list: FixedList): ListF[FixedList] =
   ???
```

---

## Projecting `Fix`

```scala
def projectFixedList(fix: Fix[ListF]): ListF[Fix[ListF]] =
  ???
```

---

## Projecting `Fix`

```scala
def projectFixedList(fix: Fix[ListF]): ListF[Fix[ListF]] =
  fix.value
```

---

## Projecting `Fix`

```scala
def projectFixedList[F[_]](fix: Fix[F]): F[Fix[F]] =
  fix.value
```

---

## Projecting `Fix`

```scala
def projectFix[F[_]](fix: Fix[F]): F[Fix[F]] =
  fix.value
```

---

## Specialised `cata` for `Fix`

```scala
def cata[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A = algebra(project(curr).fmap(loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A = algebra(project(curr).fmap(loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
  project: Fix[F] => F[Fix[F]]
): Fix[F] => A = {

  def loop(curr: Fix[F]): A = algebra(project(curr).fmap(loop))

  loop
}
```

A: Int
B: FixedList (Fix[ListF])

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
): Fix[F] => A = {

  def loop(curr: Fix[F]): A = algebra(curr.value.fmap(loop))

  loop
}
```

---

## Embedding `Fix`


```scala
def embedFix[F[_]](value: F[Fix[F]]): Fix[F] =
  Fix(value)
```

---

## Specialised `ana` for `Fix`

```scala
def ana[F[_]: Functor, A, B](
  coAlgebra: A => F[A],
  embed    : F[B] => B
): A => B = {

  def loop(curr: A): B = embed(coAlgebra(curr).fmap(loop))

  loop
}
```

---

## Specialised `ana` for `Fix`

```scala
def anaFix[F[_]: Functor, A, B](
  coAlgebra: A => F[A],
  embed    : F[B] => B
): A => B = {

  def loop(curr: A): B = embed(coAlgebra(curr).fmap(loop))

  loop
}
```

---

## Specialised `ana` for `Fix`

```scala
def anaFix[F[_]: Functor, A](
  coAlgebra: A => F[A],
  embed    : F[Fix[F]] => Fix[F]
): A => Fix[F] = {

  def loop(curr: A): Fix[F] = embed(coAlgebra(curr).fmap(loop))

  loop
}
```

A: Int
B: FixedList => Fix[ListF]

---

## Specialised `ana` for `Fix`

```scala
def anaFix[F[_]: Functor, A](
  coAlgebra: A => F[A]
): A => Fix[F] = {

  def loop(curr: A): Fix[F] = Fix((coAlgebra(curr).fmap(loop)))

  loop
}
```

---

## Range in terms of `anaFix`

```scala
val rangeFix: Int => FixedList =
  anaFix(rangeCoAlgebra)
```

```scala
rangeFix(3)
// res10: FixedList = Fix(Some((3,Fix(Some((2,Fix(Some((1,Fix(None))))))))))
```

---

## mkString in terms of `cataFix`

```scala
val mkStringFix: FixedList => String =
  cataFix(mkStringAlgebra)
```

```scala
mkStringFix(rangeFix(3))
// res11: String = 3 :: 2 :: 1 :: nil
```

---

## Cost of `Fix`

```scala
def headOpt(list: FixedList): Option[Int] = list match {
  case Fix(Some((head, _))) => Some(head)
  case Fix(None)            => None
}
```

---

## Key takeaways

* `Fix` makes the hard case easier.
* `Fix` makes the easy case harder.


---

class: center, middle

# Generalised generalised folds!

---

```scala
val factorial: Int => Int =
  range andThen product
```

```scala
factorial(3)
// res12: Int = 6
```

---

```scala
val factorial: Int => Int =
  cata(productAlgebra, rangeCoAlgebra)
```

```scala
factorial(3)
// res13: Int = 6
```

---

class: center, middle

# Questions?

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

[@NicolasRinaudo]:https://twitter.com/NicolasRinaudo
[Besedo]:https://twitter.com/besedo_official

    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
          highlightStyle: 'github',
          highlightSpans: true,
          highlightLines: true
      });
    </script>
  </body>
</html>
