<!DOCTYPE html>
<html>
    <head>
        <title>Recursion schemes from the ground up</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link rel="stylesheet" type="text/css" href="css/style.css"/>
    </head>
    <body>
        <textarea id="source">
class: center, middle

# Recursion schemes from the ground up

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

---

class: center, middle

# Recursive Data Types

---

## Linked list

.center[![Linked List](img/list.svg)]

---

## Linked list

.center[![Linked List - Cons](img/list-1.svg)]

---

## Linked list

.center[![Linked List - Nil](img/list-nil.svg)]

---

## Linked list

.center[![Linked List - Cons](img/list-1.svg)]

---

## Linked list

.center[![Linked List - head](img/list-1-head.svg)]

---

## Linked list

.center[![Linked List - tail](img/list-1-tail.svg)]

---

## Linked list

.center[![Linked list - rest](img/list-1-rest.svg)]

---

## Linked list

.center[![Linked List - Nil](img/list-nil.svg)]

---

## Linked list

```scala
sealed trait List

case class Cons(
  head: Int,
  tail: List
) extends List

case object Nil extends List
```

---

## Linked list

```scala
*sealed trait List

case class Cons(
  head: Int,
  tail: List
) extends List

case object Nil extends List
```

---

## Linked list

```scala
sealed trait List

*case class Cons(
* head: Int,
* tail: List
*) extends List

case object Nil extends List
```

---

## Linked list

```scala
sealed trait List

case class Cons(
  head: Int,
  tail: List
) extends List

*case object Nil extends List
```

---

## Linked list

```scala
sealed trait List

*case class Cons(
* head: Int,
* tail: List
*) extends List

case object Nil extends List
```

---

## Linked list

```scala
sealed trait List

case class Cons(
  `head: Int`,
  tail: List
) extends List

case object Nil extends List
```

---

## Linked list

```scala
sealed trait List

case class Cons(
  head: Int,
  `tail: List`
) extends List

case object Nil extends List
```

---

## Linked list

```scala
sealed trait List

case class Cons(
  head: Int,
  tail: List
) extends List

case object Nil extends List
```

---

## Linked list

```scala
val ints: List = Cons(1, Cons(2, Cons(3, Nil)))
```

---

## Linked list

```scala
val ints: List = Cons(`1`, Cons(`2`, Cons(`3`, Nil)))
```

---

class: center, middle

# Structural Recursion

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = ???
```

.center[![List product](img/list.svg)]

---

## Product

```scala
def product(
  `values: List`
): Int =
  values match {
    case Cons(head, tail) => head * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = ???
```

.center[![List product](img/list.svg)]

---

## Product

```scala
def product(
  values: List
): `Int` =
  values match {
    case Cons(head, tail) => head * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = ???
```

.center[![List product](img/list.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case `Cons(head, tail)` => head * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = ???
```

.center[![List product: 1](img/list-product-1-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => `head` * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = `1` * ???
```

.center[![List product: 1](img/list-product-1-head-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head `*` product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = 1 `*` ???
```

.center[![List product: 1](img/list-product-1-tail-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head * `product(tail)`
    case Nil              => 1
  }
```

```scala
product(ints) = 1 * `???`
```

.center[![List product](img/list-product-1.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case `Cons(head, tail)` => head * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = 1 * ???
```

.center[![List product](img/list-product-2-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => `head` * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = 1 * `2` * ???
```

.center[![List product](img/list-product-2-head-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head `*` product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = 1 * 2 `*` ???
```

.center[![List product](img/list-product-2-tail-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head * `product(tail)`
    case Nil              => 1
  }
```

```scala
product(ints) = 1 * 2 * `???`
```

.center[![List product](img/list-product-2.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case `Cons(head, tail)` => head * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = 1 * 2 * ???
```

.center[![List product](img/list-product-3-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => `head` * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = 1 * 2 * `3` * ???
```

.center[![List product](img/list-product-3-head-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head `*` product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = 1 * 2 * 3 `*` ???
```

.center[![List product](img/list-product-3-tail-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head * `product(tail)`
    case Nil              => 1
  }
```

```scala
product(ints) = 1 * 2 * 3 * `???`
```

.center[![List product](img/list-product-3.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head * product(tail)
    case `Nil`              => 1
  }
```

```scala
product(ints) = 1 * 2 * 3 * ???
```

.center[![List product](img/list-product-3.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head * product(tail)
    case Nil              => `1`
  }
```

```scala
product(ints) = 1 * 2 * 3 * `1`
```

.center[![List product](img/list-product-3.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints) = `1 * 2 * 3 * 1`
```

.center[![List product](img/list-product-3.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints)
// res0: Int = 6
```

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    `case Cons(head, tail)` => head * product(tail)
    case Nil              => 1
  }
```

```scala
product(ints)
```

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => `head * product(tail)`
    case Nil              => 1
  }
```

```scala
product(ints)
```

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head * product(tail)
    `case Nil`              => 1
  }
```

```scala
product(ints)
```

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head * product(tail)
    case Nil              => `1`
  }
```

```scala
product(ints)
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + mkString(tail)
    case Nil              => "nil"
  }
```

---

## String representation

```scala
def mkString(
  `values: List`
): String =
  values match {
    case Cons(head, tail) => head + " :: " + mkString(tail)
    case Nil              => "nil"
  }
```

---

## String representation

```scala
def mkString(
  values: List
): `String` =
  values match {
    case Cons(head, tail) => head + " :: " + mkString(tail)
    case Nil              => "nil"
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    `case Cons(head, tail)` => head + " :: " + mkString(tail)
    case Nil              => "nil"
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Cons(head, tail) => `head` + " :: " + mkString(tail)
    case Nil              => "nil"
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + `" :: "` + mkString(tail)
    case Nil              => "nil"
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + `mkString(tail)`
    case Nil              => "nil"
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + mkString(tail)
    `case Nil`              => "nil"
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + mkString(tail)
    case Nil              => `"nil"`
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + mkString(tail)
    case Nil              => "nil"
  }
```

```scala
mkString(ints)
// res1: String = 1 :: 2 :: 3 :: nil
```

---

## Key takeaways

Structural recursion works by:
--

* providing a solution to the smallest problem.
--

* for larger problems: relying on the solution to smaller problems.
--

* if this makes you think of proof by induction, well done.

---

class: center, middle

# Generalised structural recursion

---

## Generalising `mkString`

```scala
def mkString(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + mkString(tail)
    case Nil              => "nil"
  }
```

---

## Generalising `mkString`

```scala
def `mkString`(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + `mkString`(tail)
    case Nil              => "nil"
  }
```

---

## Generalising `mkString`

```scala
def `recurse`(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + `recurse`(tail)
    case Nil              => "nil"
  }
```

---

## Generalising `mkString`

```scala
def recurse(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + recurse(tail)
    case Nil              => "nil"
  }
```

```scala
recurse(ints)
// res2: String = 1 :: 2 :: 3 :: nil
```

---

## Generalising `mkString`

.center[![fold - step 1](img/fold-init.svg)]

---

## Generalising `mkString`

.center[![fold - overview](img/fold-init-hl-1.svg)]

---

## Generalising `mkString`

.center[![fold - overview](img/fold-init-hl-2.svg)]

---

## Generalising `mkString`

.center[![fold - overview](img/fold-init-hl-3.svg)]

---

## Generalising `mkString`

.center[![fold - overview](img/fold-init-hl-4.svg)]


---

## Generalising `mkString`

.center[![fold - overview](img/fold-init-hl-5.svg)]


---

## Generalising `mkString`

.center[![fold - overview](img/fold-init-hl-6.svg)]


---

## Generalising `mkString`

.center[![fold - overview](img/fold-init-hl-7.svg)]

---

## Generalising the base case

.center[![fold - base case](img/fold-base.svg)]

---

## Generalising the base case

```scala
def recurse(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + recurse(tail)
    case Nil              => `"nil"`
  }
```

---

## Generalising the base case

```scala
def recurse(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + recurse(tail)
    case Nil              => "nil"
  }
```

```scala
&#x200B;`val base: String = "nil"`
```

---

## Generalising the base case

```scala
def recurse(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + recurse(tail)
    case Nil              => `"nil"`
  }
```

```scala
val base: String = "nil"
```

---

## Generalising the base case

```scala
def recurse(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + recurse(tail)
    case Nil              => `base`
  }
```

```scala
val base: String = "nil"
```

---

## Generalising the base case

```scala
def recurse(
  `base  : String`,
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + recurse(tail)
    case Nil              => base
  }
```

---

## Generalising the base case

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + recurse(`base`, tail)
    case Nil              => base
  }
```

---

## Generalising the base case

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + recurse(base, tail)
    case Nil              => base
  }
```

```scala
recurse(base, ints)
// res3: String = 1 :: 2 :: 3 :: nil
```

---

## Generalising the base case

.center[![fold - base case](img/fold-base.svg)]

---

## Generalising the base case

.center[![fold - base case](img/fold-base-after-hl-1.svg)]


---

## Generalising the base case

.center[![fold - base case](img/fold-base-after.svg)]

---

## Generalising the step

.center[![fold - step case](img/fold-step.svg)]

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Cons(head, tail) => `head + " :: " + recurse(base, tail)`
    case Nil              => base
  }
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Cons(head, tail) => `head` + " :: " + recurse(base, tail)
    case Nil              => base
  }
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + `recurse(base, tail)`
    case Nil              => base
  }
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + recurse(base, tail)
    case Nil              => base
  }
```

```scala
*def step(head: Int, tail: String): String =
* head + " :: " + tail
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Cons(head, tail) => `head + " :: " + recurse(base, tail)`
    case Nil              => base
  }
```

```scala
def step(head: Int, tail: String): String =
  head + " :: " + tail
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Cons(head, tail) => `step(head, recurse(base, tail))`
    case Nil              => base
  }
```

```scala
def step(head: Int, tail: String): String =
  head + " :: " + tail
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  `step  : (Int, String) => String,`
  values: List
): String =
  values match {
    case Cons(head, tail) => step(head, recurse(base, tail))
    case Nil              => base
  }
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  step  : (Int, String) => String,
  values: List
): String =
  values match {
    case Cons(head, tail) => step(head, recurse(base, `step`, tail))
    case Nil              => base
  }
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  step  : (Int, String) => String,
  values: List
): String =
  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
```

```scala
recurse(base, step, ints)
// res4: String = 1 :: 2 :: 3 :: nil
```

---

## Generalising the step

.center[![fold - step case](img/fold-step.svg)]

---

## Generalising the step

.center[![fold - step case](img/fold-step-after-hl-1.svg)]

---

## Generalising the step

.center[![fold - step case](img/fold-step-after.svg)]


---

## Generalising the return type

.center[![fold - return type](img/fold-return.svg)]

---

## Generalising the return type

```scala
def recurse(
  base  : `String`,
  step  : (Int, `String`) => `String`,
  values: List
): `String` =
  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
```

---

## Generalising the return type

```scala
def recurse[`A`](
  base  : `A`,
  step  : (Int, `A`) => `A`,
  values: List
): `A` =
  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
```

---

## Generalising the return type

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A =
  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
```

```scala
recurse(base, step, ints)
// res5: String = 1 :: 2 :: 3 :: nil
```

---

## Generalising the return type

.center[![fold - return type](img/fold-return.svg)]

---

## Generalising the return type

.center[![fold - return type](img/fold-return-after-hl-1.svg)]

---

## Generalising the return type

.center[![fold - return type](img/fold-return-after.svg)]

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A =
  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
```


---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A =
  values match {
    case Cons(head, tail) => step(head, `recurse(base, step, tail)`)
    case Nil              => base
  }
```

---

## Simplifying the step

```scala
def recurse[A](
  `base`  : A,
  step  : (Int, A) => A,
  values: List
): A =
  values match {
    case Cons(head, tail) => step(head, recurse(`base`, step, tail))
    case Nil              => base
  }
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  `step`  : (Int, A) => A,
  values: List
): A =
  values match {
    case Cons(head, tail) => step(head, recurse(base, `step`, tail))
    case Nil              => base
  }
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A =
* values match {
*   case Cons(head, tail) => step(head, recurse(base, step, tail))
*   case Nil              => base
* }
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
* def loop(curr: List): A =
*   curr match {
*     case Cons(head, tail) =>
*       step(head, recurse(base, step, tail))
*     case Nil              => base
*   }

  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(`curr: List`): A =
    curr match {
      case Cons(head, tail) =>
        step(head, recurse(base, step, tail))
      case Nil              => base
    }

  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  `base`  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) =>
        step(head, recurse(base, step, tail))
      case Nil              => `base`
    }

  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  `step`  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) =>
        `step`(head, recurse(base, step, tail))
      case Nil              => base
    }

  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) =>
        step(head, `recurse(base, step, tail)`)
      case Nil              => base
    }

  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) =>
        step(head, `loop(tail)`)
      case Nil              => base
    }

  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) =>
        `step(head, loop(tail))`
      case Nil              => base
    }

  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => `step(head, loop(tail))`
      case Nil              => base
    }

  values match {
    case Cons(head, tail) => step(head, recurse(base, step, tail))
    case Nil              => base
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

* values match {
*   case Cons(head, tail) => step(head, recurse(base, step, tail))
*   case Nil              => base
* }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  `loop(values)`
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop(values)
}
```

```scala
recurse(base, step, ints)
// res6: String = 1 :: 2 :: 3 :: nil
```

---

## Simplifying the step

.center[![fold - recurse to loop](img/fold-return-after.svg)]

---

## Simplifying the step

.center[![fold - recurse to loop](img/fold-loop-before.svg)]

---

## Simplifying the step

.center[![fold - recurse to loop](img/fold-loop-hl-1.svg)]


---

## Simplifying the step

.center[![fold - recurse to loop](img/fold-loop.svg)]

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  `values: List`
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop(`values`)
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  `loop`
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): A = {
* def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): `A` = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): `List => A` = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

```scala
recurse(base, step)(ints)
// res7: String = 1 :: 2 :: 3 :: nil
```

---

## Dropping parameters

```scala
val mkString: List => String =
  recurse(base, step)
```

---

## Dropping parameters

```scala
val `mkString`: List => String =
  recurse(base, step)
```

---

## Dropping parameters

```scala
val mkString: List => String =
  `recurse(base, step)`
```

---

## Dropping parameters

```scala
val mkString: List => String =
  recurse(base, step)
```

```scala
mkString(ints)
// res8: String = 1 :: 2 :: 3 :: nil
```

---

## Naming things

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Naming things

```scala
def `recurse`[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Naming things

```scala
def `fold`[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Naming things

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {
  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

```scala
fold(base, step)(ints)
// res9: String = 1 :: 2 :: 3 :: nil
```

---

## `product` as a fold

```scala
val product: List => Int =
  fold[Int](
    base = 1,
    step = (head, tail) => head * tail
  )
```

---

## `product` as a fold

```scala
val product: List => Int =
  `fold`[Int](
    base = 1,
    step = (head, tail) => head * tail
  )
```

---

## `product` as a fold

```scala
val product: List => Int =
  fold[Int](
    `base = 1`,
    step = (head, tail) => head * tail
  )
```

---

## `product` as a fold

```scala
val product: List => Int =
  fold[Int](
    base = 1,
    `step = (head, tail) => head * tail`
  )
```

---

## `product` as a fold

```scala
val product: List => Int =
  fold[Int](
    base = 1,
    step = (head, tail) => head * tail
  )
```

```scala
product(ints)
// res10: Int = 6
```

---

## `mkString` as a fold

```scala
val mkString: List => String =
  fold[String](
    base = "nil",
    step = (head, tail) => head + " :: " + tail
  )
```

---

## `mkString` as a fold

```scala
val mkString: List => String =
  `fold`[String](
    base = "nil",
    step = (head, tail) => head + " :: " + tail
  )
```

---

## `mkString` as a fold

```scala
val mkString: List => String =
  fold[String](
    `base = "nil"`,
    step = (head, tail) => head + " :: " + tail
  )
```

---

## `mkString` as a fold

```scala
val mkString: List => String =
  fold[String](
    base = "nil",
    `step = (head, tail) => head + " :: " + tail`
  )
```

---

## `mkString` as a fold

```scala
val mkString: List => String =
  fold[String](
    base = "nil",
    step = (head, tail) => head + " :: " + tail
  )
```

```scala
mkString(ints)
// res11: String = 1 :: 2 :: 3 :: nil
```

---

## Key takeaways

Structural recursion generalises by:
--

* parameterising the base case.
--

* parameterising the step case.
--

* ... knowing the structure of your type.

---

class: center, middle

# Generalised folds

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Generalised folds

.center[![Cata step 1](img/cata-1.svg)]

---

## Abstracting over structure

.center[![Cata step 1](img/cata-1-hl-1.svg)]

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    curr match {
      case `Cons(head, tail)` => step(head, loop(tail))
      case `Nil`              => base
    }

  loop
}
```

---

## List projection

```scala
val project: List => Option[(Int, List)] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => None
  }
```

---

## List projection

```scala
val `project`: List => Option[(Int, List)] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => None
  }
```

---

## List projection

```scala
val project: `List => Option[(Int, List)]` =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => None
  }
```

---

## List projection

```scala
val project: List => Option[(Int, List)] =
  _ match {
    case `Cons(head, tail)` => Some((head, tail))
    case Nil              => None
  }
```

---

## List projection

```scala
val project: List => Option[(Int, List)] =
  _ match {
    case Cons(head, tail) => `Some((head, tail))`
    case Nil              => None
  }
```

---

## List projection

```scala
val project: List => Option[(Int, List)] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case `Nil`              => None
  }
```

---

## List projection

```scala
val project: List => Option[(Int, List)] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => `None`
  }
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    curr match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    `curr` match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    `project(curr)` match {
      case Cons(head, tail) => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case `Cons(head, tail)` => step(head, loop(tail))
      case Nil              => base
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case `Some((head, tail))` => step(head, loop(tail))
      case Nil                => base
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => step(head, loop(tail))
      case `Nil`                => base
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => step(head, loop(tail))
      case `None`               => base
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    `project`(curr) match {
      case Some((head, tail)) => step(head, loop(tail))
      case None               => base
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base   : A,
  step   : (Int, A) => A,
  `project: List => Option[(Int, List)]`
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => step(head, loop(tail))
      case None               => base
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base   : A,
  step   : (Int, A) => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => step(head, loop(tail))
      case None               => base
    }

  loop
}
```

```scala
fold(base, step, project)(ints)
// res12: String = 1 :: 2 :: 3 :: nil
```

---

## Abstracting over structure

.center[![Cata step 1](img/cata-1-hl-1.svg)]

---

## Abstracting over structure

.center[![Cata step 2](img/cata-2-hl-1.svg)]

---

## Abstracting over structure

.center[![Cata step 2](img/cata-2.svg)]

---

## Abstracting over structure

.center[![Cata step 2](img/cata-2-hl-2.svg)]

---

## Abstracting over structure

```scala
def fold[A](
* base   : A,
* step   : (Int, A) => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => step(head, loop(tail))
      case None               => base
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case Some((head, tail)) => step(head, tail)
    case None               => base
  }
```

---

## Simplifying `base` and `step`

```scala
val `op`: Option[(Int, String)] => String =
  _ match {
    case Some((head, tail)) => step(head, tail)
    case None               => base
  }
```

---

## Simplifying `base` and `step`

```scala
val op: `Option[(Int, String)] => String` =
  _ match {
    case Some((head, tail)) => step(head, tail)
    case None               => base
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case `Some((head, tail))` => step(head, tail)
    case None               => base
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case Some((head, tail)) => `step(head, tail)`
    case None               => base
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case Some((head, tail)) => `head + " :: " + tail`
    case None               => base
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case `None`               => base
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case None               => `base`
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case None               => `"nil"`
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case None               => "nil"
  }
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
* base   : A,
* step   : (Int, A) => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => step(head, loop(tail))
      case None               => base
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
* op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => step(head, loop(tail))
      case None               => base
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => `step(head, loop(tail))`
      case None               => base
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => `op(Some((head, loop(tail))))`
      case None               => base
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => op(Some((head, loop(tail))))
      case None               => `base`
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => op(Some((head, loop(tail))))
      case None               => `op(None)`
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => op(Some((head, loop(tail))))
      case None               => op(None)
    }

  loop
}
```

```scala
fold(op, project)(ints)
// res13: String = 1 :: 2 :: 3 :: nil
```

---

## Abstracting over structure

.center[![Cata step 2](img/cata-2-hl-2.svg)]

---

## Simplifying `base` and `step`

.center[![Cata step 3](img/cata-3-hl-1.svg)]

---

## Moving `op`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case Some((head, tail)) => `op`(Some((head, loop(tail))))
      case None               => `op`(None)
    }

  loop
}
```

---

## Moving `op`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    `op`(project(curr) match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    })

  loop
}
```

---

## Moving `op`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    `op`(project(curr) match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    })

  loop
}
```

```scala
fold(op, project)(ints)
// res14: String = 1 :: 2 :: 3 :: nil
```

---

## Simplifying `base` and `step`

.center[![Cata step 3](img/cata-3-hl-1.svg)]


---

## Simplifying `base` and `step`

.center[![Cata step 4](img/cata-4-hl-1.svg)]

---

## Simplifying `base` and `step`

.center[![Cata step 4](img/cata-4.svg)]

---

## Simplifying `base` and `step`

.center[![Cata step 4](img/cata-4-hl-2.svg)]

---

## Intermediate representation

```scala
type ListF[A] = Option[(Int, A)]
```

---

## Intermediate representation

```scala
type `ListF[A]` = Option[(Int, A)]
```

---

## Intermediate representation

```scala
type ListF[A] = `Option[(Int, A)]`
```

---

## Intermediate representation

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    })

  loop
}
```

---

## Intermediate representation

```scala
def fold[A](
  op     : `Option[(Int, A)]` => A,
  project: List => `Option[(Int, List)]`
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    })

  loop
}
```

---

## Intermediate representation

```scala
def fold[A](
  op     : `ListF[A]` => A,
  project: List => `ListF[List]`
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    })

  loop
}
```

---

## Intermediate representation

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    })

  loop
}
```

```scala
fold(op, project)(ints)
// res15: String = 1 :: 2 :: 3 :: nil
```

---

## Intermediate representation

.center[![Cata step 4](img/cata-4-hl-2.svg)]

---

## Intermediate representation

.center[![Cata step 5](img/cata-5-hl-1.svg)]

---

## Intermediate representation

.center[![Cata step 5](img/cata-5.svg)]

---

## Intermediate representation

```scala
type ListF[A] = Option[(Int, A)]
```

--

```scala
val project: List => ListF[List] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => None
  }
```

---

## Intermediate representation

```scala
type ListF[`A`] = Option[(Int, A)]
```

```scala
val project: List => ListF[`List`] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => None
  }
```

---

## Intermediate representation

```scala
type ListF[A] = Option[(Int, A)]
```

```scala
val op: ListF[String] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case None               => "nil"
  }
```

---

## Intermediate representation

```scala
type ListF[`A`] = Option[(Int, A)]
```

```scala
val op: ListF[`String`] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case None               => "nil"
  }
```

---

## Moving `op`

.center[![Cata step 5](img/cata-5.svg)]

---

## Moving `op`

.center[![Cata step 5](img/cata-5-hl-2.svg)]

---

## Moving `op`

.center[![Cata step 5](img/cata-5-hl-3.svg)]

---

## Moving `op`

.center[![Cata step 5](img/cata-5-hl-4.svg)]

---

## Moving `op`

.center[![Cata step 5](img/cata-5-hl-5.svg)]

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
*     case Some((head, tail)) => Some((head, loop(tail)))
*     case None               => None
    })

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case `Some((head, tail))` => Some((head, loop(tail)))
      case None               => None
    })

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case Some((head, tail)) => `Some((head, loop(tail)))`
      case None               => None
    })

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case `None`               => None
    })

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => `None`
    })

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
*   op(project(curr) match {
*     case Some((head, tail)) => Some((head, loop(tail)))
*     case None               => None
*   })

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    })

* def recurse(curr: ListF[List]): ListF[A] =
*   curr match {
*     case Some((head, tail)) => Some((head, loop(tail)))
*     case None               => None
*   }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
*   op(project(curr) match {
*     case Some((head, tail)) => Some((head, loop(tail)))
*     case None               => None
*   })

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(`recurse`(project(curr)))

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: `ListF[List]`): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List]): `ListF[A]` =
    curr match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, `loop(tail)`))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: `List`): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): `A` =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List], `f: List => A`): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, loop(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, `loop`(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, `f`(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), `loop`))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, f(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, f(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: `ListF[List]`, f: List => A): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, f(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: `List => A`): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, f(tail)))
      case None               => None
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): `ListF[A]` =
    curr match {
      case Some((head, tail)) => Some((head, f(tail)))
      case None               => None
    }

  loop
}
```

---

## Functor

```scala
trait Functor[F[_]] {
  def map[A, B](fa: F[A], f: A => B): F[B]
}
```

---

## Functor

```scala
trait `Functor`[F[_]] {
  def map[A, B](fa: F[A], f: A => B): F[B]
}
```

---

## Functor

```scala
trait Functor[`F[_]`] {
  def map[A, B](fa: F[A], f: A => B): F[B]
}
```

---

## Functor

```scala
trait Functor[F[_]] {
  def `map`[A, B](fa: F[A], f: A => B): F[B]
}
```

---

## Functor

```scala
trait Functor[F[_]] {
  def map[A, B](`fa: F[A]`, f: A => B): F[B]
}
```

---

## Functor

```scala
trait Functor[F[_]] {
  def map[A, B](fa: F[A], `f: A => B`): F[B]
}
```

---

## Functor

```scala
trait Functor[F[_]] {
  def map[A, B](fa: F[A], f: A => B): `F[B]`
}
```

---

## Functor

```scala
implicit val listFFunctor = new Functor[ListF] {
  override def map[A, B](list: ListF[A], f: A => B) =
    list match {
      case Some((head, tail)) => Some((head, f(tail)))
      case None               => None
    }
}
```

---

## Functor

```scala
implicit val listFFunctor = new `Functor[ListF]` {
  override def map[A, B](list: ListF[A], f: A => B) =
    list match {
      case Some((head, tail)) => Some((head, f(tail)))
      case None               => None
    }
}
```

---

## Functor

```scala
implicit val listFFunctor = new Functor[ListF] {
  override def map[A, B](list: ListF[A], f: A => B) =
*   list match {
*     case Some((head, tail)) => Some((head, f(tail)))
*     case None               => None
*   }
}
```

---

## Functor

```scala
implicit val listFFunctor = new Functor[ListF] {
  override def map[A, B](list: ListF[A], f: A => B) =
    list match {
      case `Some((head, tail))` => Some((head, f(tail)))
      case None               => None
    }
}
```

---

## Functor

```scala
implicit val listFFunctor = new Functor[ListF] {
  override def map[A, B](list: ListF[A], f: A => B) =
    list match {
      case Some((head, tail)) => Some((head, `f(tail)`))
      case None               => None
    }
}
```

---

## Functor

```scala
implicit val listFFunctor = new Functor[ListF] {
  override def map[A, B](list: ListF[A], f: A => B) =
    list match {
      case Some((head, tail)) => Some((head, f(tail)))
      case `None`               => None
    }
}
```

---

## Functor

```scala
implicit val listFFunctor = new Functor[ListF] {
  override def map[A, B](list: ListF[A], f: A => B) =
    list match {
      case Some((head, tail)) => Some((head, f(tail)))
      case None               => `None`
    }
}
```

---

## Functor

```scala
def fmap[F[_], A, B](
  fa     : F[A],
  f      : A => B
)(implicit
  functor: Functor[F]
): F[B] =
  functor.map(fa, f)
```

---

## Functor

```scala
def `fmap`[F[_], A, B](
  fa     : F[A],
  f      : A => B
)(implicit
  functor: Functor[F]
): F[B] =
  functor.map(fa, f)
```

---

## Functor

```scala
def fmap[F[_], A, B](
  `fa     : F[A]`,
  f      : A => B
)(implicit
  functor: Functor[F]
): F[B] =
  functor.map(fa, f)
```

---

## Functor

```scala
def fmap[F[_], A, B](
  fa     : F[A],
  `f      : A => B`
)(implicit
  functor: Functor[F]
): F[B] =
  functor.map(fa, f)
```

---

## Functor

```scala
def fmap[F[_], A, B](
  fa     : F[A],
  f      : A => B
)(implicit
  `functor: Functor[F]`
): F[B] =
  functor.map(fa, f)
```

---

## Functor

```scala
def fmap[F[_], A, B](
  fa     : F[A],
  f      : A => B
)(implicit
  functor: Functor[F]
): F[B] =
  `functor.map(fa, f)`
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    curr match {
      case Some((head, tail)) => Some((head, f(tail)))
      case None               => None
    }

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
*   curr match {
*     case Some((head, tail)) => Some((head, f(tail)))
*     case None               => None
*   }

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    `fmap(curr, f)`

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(`recurse`(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    fmap(curr, f)

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(`fmap`(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    fmap(curr, f)

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

* def recurse(curr: ListF[List], f: List => A): ListF[A] =
*   fmap(curr, f)

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

```scala
fold(op, project)(ints)
// res16: String = 1 :: 2 :: 3 :: nil
```

---

## Using Functor

.center[![Cata step 5](img/cata-5-hl-2.svg)]

---

## Using Functor

.center[![Cata step 6](img/cata-6-hl-1.svg)]

---

## Using Functor

.center[![Cata step 6](img/cata-6.svg)]

---

## Abstracting over `ListF`

.center[![Cata step 6](img/cata-6-hl-2.svg)]

---

## Abstracting over `ListF`

```scala
def fold[A](
  op     : `ListF`[A] => A,
  project: List => `ListF`[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `ListF`

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(`fmap`(project(curr), loop))

  loop
}
```

---

## Abstracting over `ListF`

```scala
def fold[`F[_]: Functor`, A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `ListF`

```scala
def fold[F[_]: Functor, A](
  op     : `ListF`[A] => A,
  project: List => `ListF`[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `ListF`

```scala
def fold[F[_]: Functor, A](
  op     : `F`[A] => A,
  project: List => `F`[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `ListF`

```scala
def fold[F[_]: Functor, A](
  op     : F[A] => A,
  project: List => F[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

```scala
fold(op, project).apply(ints)
// res17: String = 1 :: 2 :: 3 :: nil
```

---

## Abstracting over `ListF`

.center[![Cata step 6](img/cata-6-hl-2.svg)]

---

## Abstracting over `ListF`

.center[![Cata step 7](img/cata-7-hl-1.svg)]

---

## Abstracting over `ListF`

.center[![Cata step 7](img/cata-7.svg)]

---

## Abstracting over `ListF`

.center[![Cata step 7](img/cata-7-hl-2.svg)]

---

## Abstracting over `List`

```scala
def fold[F[_]: Functor, A](
  op     : F[A] => A,
  project: `List` => F[`List`]
): `List` => A = {

  def loop(curr: `List`): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `List`

```scala
def fold[F[_]: Functor, A, `B`](
  op     : F[A] => A,
  project: List => F[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `List`

```scala
def fold[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: `List` => F[`List`]
): `List` => A = {

  def loop(curr: `List`): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `List`

```scala
def fold[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: `B` => F[`B`]
): `B` => A = {

  def loop(curr: `B`): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `List`

```scala
def fold[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    op(fmap(project(curr), loop))

  loop
}
```

```scala
fold(op, project).apply(ints)
// res18: String = 1 :: 2 :: 3 :: nil
```

---

## Abstracting over `List`

.center[![Cata step 7](img/cata-7-hl-2.svg)]

---

## Abstracting over `List`

.center[![Cata step 8](img/cata-8-hl-1.svg)]

---

## Abstracting over `List`

.center[![Cata step 8](img/cata-8.svg)]

---

## Naming things

```scala
def `fold`[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Naming things

```scala
def `cata`[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Naming things

```scala
def cata[F[_]: Functor, A, B](
  `op`     : F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    `op`(fmap(project(curr), loop))

  loop
}
```

---

## Naming things

```scala
def cata[F[_]: Functor, A, B](
  `algebra`: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    `algebra`(fmap(project(curr), loop))

  loop
}
```

---

## Naming things

```scala
def cata[`F[_]: Functor`, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## Naming things

```scala
def cata[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

```scala
cata(op, project).apply(ints)
// res19: String = 1 :: 2 :: 3 :: nil
```

---

## Naming things

.center[![Cata step 8](img/cata-8.svg)]

---

## Naming things

.center[![Cata step 9](img/cata-9-hl-1.svg)]

---

## Naming things

.center[![Cata step 9](img/cata-9-hl-2.svg)]

---

## Naming things

.center[![Cata step 9](img/cata-9.svg)]

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case Some((head, tail)) => head * tail
    case None               => 1
  }

val product: List => Int =
  cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val `productAlgebra`: ListF[Int] => Int =
  _ match {
    case Some((head, tail)) => head * tail
    case None               => 1
  }

val product: List => Int =
  cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val productAlgebra: `ListF[Int] => Int` =
  _ match {
    case Some((head, tail)) => head * tail
    case None               => 1
  }

val product: List => Int =
  cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case `Some((head, tail))` => head * tail
    case None               => 1
  }

val product: List => Int =
  cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case Some((head, tail)) => `head * tail`
    case None               => 1
  }

val product: List => Int =
  cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case Some((head, tail)) => head * tail
    case `None`               => 1
  }

val product: List => Int =
  cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case Some((head, tail)) => head * tail
    case None               => `1`
  }

val product: List => Int =
  cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case Some((head, tail)) => head * tail
    case None               => 1
  }

val product: List => Int =
  `cata(productAlgebra, project)`
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case Some((head, tail)) => head * tail
    case None               => 1
  }

val product: List => Int =
  cata(productAlgebra, project)
```

```scala
product(ints)
// res20: Int = 6
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case None               => "nil"
  }

val mkString: List => String =
  cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val `mkStringAlgebra`: ListF[String] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case None               => "nil"
  }

val mkString: List => String =
  cata(mkStringAlgebra, project)
```


---

## `mkString` as a cata

```scala
val mkStringAlgebra: `ListF[String] => String` =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case None               => "nil"
  }

val mkString: List => String =
  cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case `Some((head, tail))` => head + " :: " + tail
    case None               => "nil"
  }

val mkString: List => String =
  cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case Some((head, tail)) => `head + " :: " + tail`
    case None               => "nil"
  }

val mkString: List => String =
  cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case `None`               => "nil"
  }

val mkString: List => String =
  cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case None               => `"nil"`
  }

val mkString: List => String =
  cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case None               => "nil"
  }

val mkString: List => String =
  `cata(mkStringAlgebra, project)`
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case Some((head, tail)) => head + " :: " + tail
    case None               => "nil"
  }

val mkString: List => String =
  cata(mkStringAlgebra, project)
```

```scala
mkString(ints)
// res21: String = 1 :: 2 :: 3 :: nil
```

---

## Key takeaways

Catamorphisms are:
--

* structural recursion for types that can be projected into pattern functors.
--

* fare less complicated than their names make them out to be.
--

* a simple refactoring away from the familiar `fold`.

---

class: center, middle

# Can this be applied to other types?

---

## Binary Tree

.center[![Tree](img/tree.svg)]

---

## Binary Tree

.center[![Tree Node](img/tree-node.svg)]

---

## Binary Tree

.center[![Tree Leaf](img/tree-leaf.svg)]

---

## Binary Tree

.center[![Tree Node](img/tree-node.svg)]

---

## Binary Tree

.center[![Tree Node](img/tree-node-hl-1.svg)]

---

## Binary Tree

.center[![Tree Node](img/tree-node-hl-2.svg)]

---

## Binary Tree

.center[![Tree Node](img/tree-node-rest.svg)]

---

## Binary Tree

.center[![Tree Node](img/tree-node-hl-3.svg)]

---

## Binary Tree

.center[![Tree Leaf](img/tree-leaf.svg)]

---

## Binary Tree

```scala
sealed trait Tree

case class Node(
  left : Tree,
  value: Int,
  right: Tree
) extends Tree

case object Leaf extends Tree
```

---

## Binary Tree

```scala
*sealed trait Tree

case class Node(
  left : Tree,
  value: Int,
  right: Tree
) extends Tree

case object Leaf extends Tree
```

---

## Binary Tree

```scala
sealed trait Tree

*case class Node(
* left : Tree,
* value: Int,
* right: Tree
*) extends Tree

case object Leaf extends Tree
```

---

## Binary Tree

```scala
sealed trait Tree

case class Node(
  left : Tree,
  value: Int,
  right: Tree
) extends Tree

*case object Leaf extends Tree
```

---

## Binary Tree

```scala
sealed trait Tree

*case class Node(
* left : Tree,
* value: Int,
* right: Tree
*) extends Tree

case object Leaf extends Tree
```

---

## Binary Tree

```scala
sealed trait Tree

case class Node(
  left : Tree,
  `value: Int`,
  right: Tree
) extends Tree

case object Leaf extends Tree
```

---

## Binary Tree

```scala
sealed trait Tree

case class Node(
  `left : Tree`,
  value: Int,
  right: Tree
) extends Tree

case object Leaf extends Tree
```

---

## Binary Tree

```scala
sealed trait Tree

case class Node(
  left : Tree,
  value: Int,
  `right: Tree`
) extends Tree

case object Leaf extends Tree
```

---

## Binary Tree

```scala
val intTree =
  Node(
    Node(
      Node(Leaf, 1, Leaf),
      2,
      Node(Leaf, 3, Leaf)
    ),
    4,
    Leaf
  )
// intTree: Node = Node(Node(Node(Leaf,1,Leaf),2,Node(Leaf,3,Leaf)),4,Leaf)
```

---

## Binary Tree

```scala
val intTree =
  Node(
    Node(
      Node(Leaf, `1`, Leaf),
      `2`,
      Node(Leaf, `3`, Leaf)
    ),
    `4`,
    Leaf
  )
```

---

## Tree Height

.center[![Tree Height](img/tree.svg)]

---

## Tree Height

.center[![Tree Height](img/tree-height.svg)]

---

## Tree Height

.center[![Tree catamorphism](img/cata-tree.svg)]

---

## Tree Height

.center[![Tree catamorphism](img/cata-tree-1.svg)]

---

## Tree Height

.center[![Tree catamorphism](img/cata-tree-2.svg)]

---

## Tree Height

.center[![Tree catamorphism](img/cata-tree-3.svg)]

---

## Tree Height

.center[![Tree catamorphism](img/cata-tree-4.svg)]

---

## Pattern functor

```scala
sealed trait Tree

case class Node(
  left : Tree,
  value: Int,
  right: Tree
) extends Tree

case object Leaf extends Tree
```

---

## Pattern functor

```scala
sealed trait `Tree`

case class Node(
  left : Tree,
  value: Int,
  right: Tree
) extends `Tree`

case object Leaf extends `Tree`
```

---

## Pattern functor

```scala
sealed trait `TreeF`

case class Node(
  left : Tree,
  value: Int,
  right: Tree
) extends `TreeF`

case object Leaf extends `TreeF`
```

---

## Pattern functor

```scala
sealed trait TreeF

case class `Node`(
  left : Tree,
  value: Int,
  right: Tree
) extends TreeF

case object Leaf extends TreeF
```

---

## Pattern functor

```scala
sealed trait TreeF

case class `NodeF`(
  left : Tree,
  value: Int,
  right: Tree
) extends TreeF

case object Leaf extends TreeF
```

---

## Pattern functor

```scala
sealed trait TreeF

case class NodeF(
  left : Tree,
  value: Int,
  right: Tree
) extends TreeF

case object `Leaf` extends TreeF
```

---

## Pattern functor

```scala
sealed trait TreeF

case class NodeF(
  left : Tree,
  value: Int,
  right: Tree
) extends TreeF

case object `LeafF` extends TreeF
```

---

## Pattern functor

```scala
sealed trait TreeF

case class NodeF(
  left : Tree,
  value: Int,
  right: Tree
) extends TreeF

case object LeafF extends TreeF
```

---

## Pattern functor

```scala
sealed trait TreeF`[A]`

case class NodeF(
  left : Tree,
  value: Int,
  right: Tree
) extends TreeF

case object LeafF extends TreeF
```

---

## Pattern functor

```scala
sealed trait TreeF[A]

*case class NodeF(
* left : Tree,
* value: Int,
* right: Tree
*) extends TreeF

case object LeafF extends TreeF
```

---

## Pattern functor

```scala
sealed trait TreeF[A]

case class NodeF`[A]`(
  left : Tree,
  value: Int,
  right: Tree
) extends TreeF`[A]`

case object LeafF extends TreeF
```

---

## Pattern functor

```scala
sealed trait TreeF[A]

case class NodeF[A](
  left : `Tree`,
  value: Int,
  right: `Tree`
) extends TreeF[A]

case object LeafF extends TreeF
```

---

## Pattern functor

```scala
sealed trait TreeF[A]

case class NodeF[A](
  left : `A`,
  value: Int,
  right: `A`
) extends TreeF[A]

case object LeafF extends TreeF
```

---

## Pattern functor

```scala
sealed trait TreeF[A]

case class NodeF[A](
  left : A,
  value: Int,
  right: A
) extends TreeF[A]

*case object LeafF extends TreeF
```

---

## Pattern functor

```scala
sealed trait TreeF[A]

case class NodeF[A](
  left : A,
  value: Int,
  right: A
) extends TreeF[A]

case object LeafF extends TreeF`[???]`
```

---

## Pattern functor

```scala
sealed trait TreeF[A]

case class NodeF[A](
  left : A,
  value: Int,
  right: A
) extends TreeF[A]

case object LeafF extends TreeF`[Nothing]`
```

---

## Pattern functor

```scala
sealed trait TreeF[`A`]

case class NodeF[A](
  left : A,
  value: Int,
  right: A
) extends TreeF[A]

case object LeafF extends TreeF[Nothing]
```

---

## Pattern functor

```scala
sealed trait TreeF[`+A`]

case class NodeF[A](
  left : A,
  value: Int,
  right: A
) extends TreeF[A]

case object LeafF extends TreeF[Nothing]
```


---

## Pattern functor

```scala
sealed trait TreeF[+A]

case class NodeF[A](
  left : A,
  value: Int,
  right: A
) extends TreeF[A]

case object LeafF extends TreeF[Nothing]
```

---

## Pattern functor

.center[![Tree catamorphism](img/cata-tree-6.svg)]

---

## Pattern functor

.center[![Tree catamorphism](img/cata-tree-7.svg)]

---

## Pattern functor

.center[![Tree catamorphism](img/cata-tree-8.svg)]

---

## Pattern functor

.center[![Tree catamorphism](img/cata-tree-9.svg)]

---

## Pattern functor

.center[![Tree catamorphism](img/cata-tree-10.svg)]

---

## Pattern functor

.center[![Tree catamorphism](img/cata-tree-11.svg)]

---

## Projection

```scala
def projectTree: Tree => TreeF[Tree] =
  _ match {
    case Node(l, v ,r) => NodeF(l, v, r)
    case Leaf          => LeafF
  }
```

---

## Projection

```scala
def projectTree: `Tree => TreeF[Tree]` =
  _ match {
    case Node(l, v ,r) => NodeF(l, v, r)
    case Leaf          => LeafF
  }
```

---

## Projection

```scala
def projectTree: Tree => TreeF[Tree] =
  _ match {
    case `Node(l, v ,r)` => NodeF(l, v, r)
    case Leaf          => LeafF
  }
```

---

## Projection

```scala
def projectTree: Tree => TreeF[Tree] =
  _ match {
    case Node(l, v ,r) => `NodeF(l, v, r)`
    case Leaf          => LeafF
  }
```

---

## Projection

```scala
def projectTree: Tree => TreeF[Tree] =
  _ match {
    case Node(l, v ,r) => NodeF(l, v, r)
    case `Leaf`          => LeafF
  }
```

---

## Projection

```scala
def projectTree: Tree => TreeF[Tree] =
  _ match {
    case Node(l, v ,r) => NodeF(l, v, r)
    case Leaf          => `LeafF`
  }
```

---

## Projection

.center[![Tree catamorphism](img/cata-tree-11.svg)]

---

## Projection

.center[![Tree catamorphism](img/cata-tree-12.svg)]

---

## Projection

.center[![Tree catamorphism](img/cata-tree-13.svg)]

---

## Projection

.center[![Tree catamorphism](img/cata-tree-14.svg)]

---

## Functor instance

```scala
implicit val treeFFunctor = new Functor[TreeF] {
  override def map[A, B](tree: TreeF[A], f: A => B) =
    tree match {
      case NodeF(left, i, right) => NodeF(f(left), i, f(right))
      case LeafF                 => LeafF
    }
}
```

---

## Functor instance

```scala
implicit val treeFFunctor = new `Functor[TreeF]` {
  override def map[A, B](tree: TreeF[A], f: A => B) =
    tree match {
      case NodeF(left, i, right) => NodeF(f(left), i, f(right))
      case LeafF                 => LeafF
    }
}
```

---

## Functor instance

```scala
implicit val treeFFunctor = new Functor[TreeF] {
  override def map[A, B](tree: TreeF[A], f: A => B) =
*   tree match {
*     case NodeF(left, i, right) => NodeF(f(left), i, f(right))
*     case LeafF                 => LeafF
*   }
}
```

---

## Functor instance

```scala
implicit val treeFFunctor = new Functor[TreeF] {
  override def map[A, B](tree: TreeF[A], f: A => B) =
    tree match {
      case `NodeF(left, i, right)` => NodeF(f(left), i, f(right))
      case LeafF                 => LeafF
    }
}
```

---

## Functor instance

```scala
implicit val treeFFunctor = new Functor[TreeF] {
  override def map[A, B](tree: TreeF[A], f: A => B) =
    tree match {
      case NodeF(left, i, right) => NodeF(`f(left)`, i, `f(right)`)
      case LeafF                 => LeafF
    }
}
```

---

## Functor instance

```scala
implicit val treeFFunctor = new Functor[TreeF] {
  override def map[A, B](tree: TreeF[A], f: A => B) =
    tree match {
      case NodeF(left, i, right) => NodeF(f(left), i, f(right))
      case `LeafF`                 => LeafF
    }
}
```

---

## Functor instance

```scala
implicit val treeFFunctor = new Functor[TreeF] {
  override def map[A, B](tree: TreeF[A], f: A => B) =
    tree match {
      case NodeF(left, i, right) => NodeF(f(left), i, f(right))
      case LeafF                 => `LeafF`
    }
}
```

---

## Functor instance

.center[![Tree catamorphism](img/cata-tree-13.svg)]

---

## Functor instance

.center[![Tree catamorphism](img/cata-tree-15.svg)]

---

## F-Algebra

```scala
val heightAlgebra: TreeF[Int] => Int =
  _ match {
    case NodeF(left, _, right) => 1 + math.max(left, right)
    case LeafF                 => 0
  }
```

---

## F-Algebra

```scala
val `heightAlgebra`: TreeF[Int] => Int =
  _ match {
    case NodeF(left, _, right) => 1 + math.max(left, right)
    case LeafF                 => 0
  }
```

---

## F-Algebra

```scala
val heightAlgebra: `TreeF[Int] => Int` =
  _ match {
    case NodeF(left, _, right) => 1 + math.max(left, right)
    case LeafF                 => 0
  }
```

---

## F-Algebra

```scala
val heightAlgebra: TreeF[Int] => Int =
  _ match {
    case `NodeF(left, _, right)` => 1 + math.max(left, right)
    case LeafF                 => 0
  }
```

---

## F-Algebra

```scala
val heightAlgebra: TreeF[Int] => Int =
  _ match {
    case NodeF(left, _, right) => `1 + math.max(left, right)`
    case LeafF                 => 0
  }
```

---

## F-Algebra

```scala
val heightAlgebra: TreeF[Int] => Int =
  _ match {
    case NodeF(left, _, right) => 1 + math.max(left, right)
    case `LeafF`                 => 0
  }
```

---

## F-Algebra

```scala
val heightAlgebra: TreeF[Int] => Int =
  _ match {
    case NodeF(left, _, right) => 1 + math.max(left, right)
    case LeafF                 => `0`
  }
```

---

## F-Algebra

.center[![Tree catamorphism](img/cata-tree-15.svg)]

---

## F-Algebra

.center[![Tree catamorphism](img/cata-tree-16.svg)]

---

## F-Algebra

.center[![Tree catamorphism](img/cata-tree-17.svg)]

---

## F-Algebra

.center[![Tree catamorphism](img/cata-tree-18.svg)]

---

## F-Algebra

.center[![Tree catamorphism](img/cata-tree-19.svg)]

---

## F-Algebra

.center[![Tree catamorphism](img/cata-tree-20.svg)]

---

## Tree height

```scala
val height: Tree => Int =
  cata(heightAlgebra, projectTree)
```

---

## Tree height

```scala
val height: Tree => Int =
  `cata(heightAlgebra, projectTree)`
```

---

## Tree height

```scala
val height: Tree => Int =
  cata(heightAlgebra, projectTree)
```

```scala
height(intTree)
// res22: Int = 3
```

---

## Tree height

.center[![Tree Height](img/tree-height.svg)]

---

## Key takeaways

* `cata` works just fine with `Tree`.
--

* it involves a lot of busywork though...

---

class: center, middle

# Reducing the boilerplate

---

## `List` in terms of `ListF`

```scala
type List2 = ListF[???]
```

---

## `List` in terms of `ListF`

```scala
type `List2` = ListF[???]
```

---

## `List` in terms of `ListF`

```scala
type List2 = `ListF[???]`
```


---

## `List` in terms of `ListF`

```scala
type List2 = ListF[`???`]
```

---

## `List` in terms of `ListF`

```scala
type List2 = ListF[`List2`]
```

---

## `List` in terms of `ListF`

```scala
type List2 = ListF[List2]
//        type List2 = ListF[List2]
//                           ^
// On line 2: error: illegal cyclic reference involving type List2
```

---

## `List` in terms of `ListF`

```scala
case class List2(value: ListF[List2])
```

---

## `List` in terms of `ListF`

```scala
case class List2(`value: ListF[List2]`)
```

---

## Generalising `List2`

```scala
case class List2(value: ListF[List2])
```


---

## Generalising `List2`

```scala
case class List2(value: `ListF`[List2])
```

---

## Generalising `List2`

```scala
case class List2[`F[_]`](value: ListF[List2])
```

---

## Generalising `List2`

```scala
case class List2[F[_]](value: `ListF`[List2])
```

---

## Generalising `List2`

```scala
case class List2[F[_]](value: `F`[List2])
```

---

## Generalising `List2`

```scala
case class List2[F[_]](value: F[`List2`])
```

---

## Generalising `List2`

```scala
case class List2[F[_]](value: F[List2[`F`]])
```

---

## Generalising `List2`

```scala
case class List2[F[_]](value: F[List2[F]])
```

---

## Naming things

```scala
case class `List2`[F[_]](value: F[`List2`[F]])
```

---

## Naming things

```scala
case class `Fix`[F[_]](value: F[`Fix`[F]])
```

---

## Naming things

```scala
case class Fix[F[_]](value: F[Fix[F]])
```

---

## `List` in terms of `Fix`

```scala
type FixedList = Fix[ListF]
```

---

## `List` in terms of `Fix`

```scala
type `FixedList` = Fix[ListF]
```


---

## `List` in terms of `Fix`

```scala
type FixedList = `Fix[ListF]`
```

---

## `List` in terms of `Fix`

```scala
val fixedInts: FixedList =
  Fix[ListF](Some((1,
    Fix[ListF](Some((2,
      Fix[ListF](Some((3,
        Fix[ListF](None)
      )))
    )))
  )))
```

---

## `List` in terms of `Fix`

```scala
val fixedInts: FixedList =
  Fix[ListF](Some((`1`,
    Fix[ListF](Some((`2`,
      Fix[ListF](Some((`3`,
        Fix[ListF](None)
      )))
    )))
  )))
```

---

## `Tree` in terms of `TreeF`

```scala
type FixedTree = Fix[TreeF]
```

---

## `Tree` in terms of `TreeF`

```scala
type `FixedTree` = Fix[TreeF]
```

---

## `Tree` in terms of `TreeF`

```scala
type FixedTree = `Fix[TreeF]`
```

---

## `Tree` in terms of `TreeF`

```scala
val fixedIntTree: FixedTree =
  Fix[TreeF](NodeF(
    Fix[TreeF](NodeF(
      Fix[TreeF](NodeF(Fix[TreeF](LeafF), 1, Fix[TreeF](LeafF))),
      2,
      Fix[TreeF](NodeF(Fix[TreeF](LeafF), 3, Fix[TreeF](LeafF)))
    )),
    4,
    Fix[TreeF](LeafF)
  ))
```

---

## `Tree` in terms of `TreeF`

```scala
val fixedIntTree: FixedTree =
  Fix[TreeF](NodeF(
    Fix[TreeF](NodeF(
      Fix[TreeF](NodeF(Fix[TreeF](LeafF), `1`, Fix[TreeF](LeafF))),
      `2`,
      Fix[TreeF](NodeF(Fix[TreeF](LeafF), `3`, Fix[TreeF](LeafF)))
    )),
    `4`,
    Fix[TreeF](LeafF)
  ))
```

---

## `cata` with `Fix`

```scala
def cata[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## `cata` with `Fix`

```scala
def `cata`[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## `cata` with `Fix`

```scala
def `cataFix`[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## `cata` with `Fix`

```scala
def cataFix[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## `cata` with `Fix`

.center[![Linked List](img/catafix-init.svg)]

---

## `cata` with `Fix`

.center[![Linked List](img/catafix-init-hl-1.svg)]

---

## `cata` with `Fix`

```scala
def cataFix[F[_]: Functor, A, `B`](
  algebra: F[A] => A,
  project: `B` => F[`B`]
): `B` => A = {

  def loop(curr: `B`): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## `cata` with `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
  project: `Fix[F]` => F[`Fix[F]`]
): `Fix[F]` => A = {

  def loop(curr: `Fix[F]`): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## `cata` with `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
  project: Fix[F] => F[Fix[F]]
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## `cata` with `Fix`

.center[![Linked List](img/catafix-init-hl-1.svg)]


---

## `cata` with `Fix`

.center[![Linked List](img/catafix-no-b-hl-1.svg)]

---

## `cata` with `Fix`

.center[![Linked List](img/catafix-no-b.svg)]

---

## `cata` with `Fix`

.center[![Linked List](img/catafix-no-b-hl-2.svg)]

---

## Projecting `Fix`

```scala
val project: List => ListF[List] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => None
  }
```

---

## Projecting `Fix`

```scala
val `project`: List => ListF[List] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => None
  }
```

---

## Projecting `Fix`

```scala
val `projectFix`: List => ListF[List] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => None
  }
```

---

## Projecting `Fix`

```scala
val projectFix: List => ListF[List] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => None
  }
```

---

## Projecting `Fix`

```scala
val projectFix: `List` => ListF[`List`] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => None
  }
```

---

## Projecting `Fix`

```scala
val projectFix: `FixedList` => ListF[`FixedList`] =
  _ match {
    case Cons(head, tail) => Some((head, tail))
    case Nil              => None
  }
```

---

## Projecting `Fix`

```scala
val projectFix: FixedList => ListF[FixedList] =
  _ match {
    case `Cons(head, tail)` => Some((head, tail))
    case Nil              => None
  }
```

---

## Projecting `Fix`

```scala
val projectFix: FixedList => ListF[FixedList] =
  _ match {
    case `Fix(Some((head, tail)))` => Some((head, tail))
    case Nil                     => None
  }
```

---

## Projecting `Fix`

```scala
val projectFix: FixedList => ListF[FixedList] =
  _ match {
    case Fix(Some((head, tail))) => Some((head, tail))
    case `Nil`                     => None
  }
```

---

## Projecting `Fix`

```scala
val projectFix: FixedList => ListF[FixedList] =
  _ match {
    case Fix(Some((head, tail))) => Some((head, tail))
    case `Fix(None)`               => None
  }
```

---

## Projecting `Fix`

```scala
val projectFix: FixedList => ListF[FixedList] =
  _ match {
    case Fix(Some((head, tail))) => Some((head, tail))
    case Fix(None)               => None
  }
```

---

## Projecting `Fix`

```scala
val projectFix: FixedList => ListF[FixedList] =
  _ match {
    case Fix(`Some((head, tail))`) => `Some((head, tail))`
    case Fix(None)               => None
  }
```

---

## Projecting `Fix`

```scala
val projectFix: FixedList => ListF[FixedList] =
  _ match {
    case Fix(Some((head, tail))) => Some((head, tail))
    case Fix(`None`)               => `None`
  }
```

---

## Projecting `Fix`

```scala
val projectFix: FixedList => ListF[FixedList] =
* _ match {
*   case Fix(Some((head, tail))) => Some((head, tail))
*   case Fix(None)               => None
* }
```

---

## Projecting `Fix`

```scala
val projectFix: FixedList => ListF[FixedList] =
* _.value
```

---

## Projecting `Fix`

```scala
val projectFix: FixedList => ListF[FixedList] =
  _.value
```

---

## Projecting `Fix`

```scala
val projectFix: `FixedList` => ListF[`FixedList`] =
  _.value
```

---

## Projecting `Fix`

```scala
val projectFix: `Fix[ListF]` => ListF[`Fix[ListF]`] =
  _.value
```

---

## Projecting `Fix`

```scala
val projectFix: Fix[ListF] => ListF[Fix[ListF]] =
  _.value
```

---

## Projecting `Fix`

```scala
val projectFix: Fix[`ListF`] => `ListF`[Fix[`ListF`]] =
  _.value
```

---

## Projecting `Fix`

```scala
&#x200B;`val projectFix`: Fix[ListF] => ListF[Fix[ListF]] =
  _.value
```

---

## Projecting `Fix`

```scala
&#x200B;`def` projectFix: Fix[ListF] => ListF[Fix[ListF]] =
  _.value
```

---

## Projecting `Fix`

```scala
def projectFix[`F[_]`]: Fix[ListF] => ListF[Fix[ListF]] =
  _.value
```

---

## Projecting `Fix`

```scala
def projectFix[F[_]]: Fix[`ListF`] => `ListF`[Fix[`ListF`]] =
  _.value
```

---

## Projecting `Fix`

```scala
def projectFix[F[_]]: Fix[`F`] => `F`[Fix[`F`]] =
  _.value
```

---

## Projecting `Fix`

```scala
def projectFix[F[_]]: Fix[F] => F[Fix[F]] =
  _.value
```

---

## Projecting `Fix`

```scala
def projectFix[F[_]]: Fix[F] => F[Fix[F]] =
  `_.value`
```

---

## Projecting `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
  project: Fix[F] => F[Fix[F]]
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## Projecting `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
  project: Fix[F] => F[Fix[F]]
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(`project(curr)`, loop))

  loop
}
```

---

## Projecting `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
  project: Fix[F] => F[Fix[F]]
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(`curr.value`, loop))

  loop
}
```

---

## Projecting `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
  `project: Fix[F] => F[Fix[F]]`
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(curr.value, loop))

  loop
}
```

---

## Projecting `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(curr.value, loop))

  loop
}
```

---

## Projecting `Fix`

.center[![Linked List](img/catafix-no-b-hl-2.svg)]

---

## Projecting `Fix`

.center[![Linked List](img/catafix-project-hl-1.svg)]

---

## Projecting `Fix`

.center[![Linked List](img/catafix-project.svg)]

---

## Projecting `Fix`

.center[![Linked List](img/catafix-project-hl-2.svg)]

---

## Projecting `Fix`

.center[![Linked List](img/catafix-project-hl-3.svg)]


---

## `product` in terms of `cataFix`

```scala
val productFix: FixedList => Int =
  cataFix(productAlgebra)
```

---

## `product` in terms of `cataFix`

```scala
val productFix: FixedList => Int =
  `cataFix(productAlgebra)`
```


---

## `product` in terms of `cataFix`

```scala
val productFix: FixedList => Int =
  cataFix(productAlgebra)
```

```scala
productFix(fixedInts)
// res23: Int = 6
```

---

## `mkString` in terms of `cataFix`

```scala
val mkStringFix: FixedList => String =
  cataFix(mkStringAlgebra)
```

---

## `mkString` in terms of `cataFix`

```scala
val mkStringFix: FixedList => String =
  `cataFix(mkStringAlgebra)`
```

---

## `mkString` in terms of `cataFix`

```scala
val mkStringFix: FixedList => String =
  cataFix(mkStringAlgebra)
```

```scala
mkStringFix(fixedInts)
// res24: String = 1 :: 2 :: 3 :: nil
```

---

## `height` in terms of `cataFix`

```scala
val heightFix: FixedTree => Int =
  cataFix(heightAlgebra)
```

---

## `height` in terms of `cataFix`

```scala
val heightFix: FixedTree => Int =
  `cataFix(heightAlgebra)`
```

---

## `height` in terms of `cataFix`

```scala
val heightFix: FixedTree => Int =
  cataFix(heightAlgebra)
```


```scala
heightFix(fixedIntTree)
// res25: Int = 3
```

---

## Cost of `Fix`

```scala
def headOpt(list: FixedList): Option[Int] = list match {
  case Fix(Some((head, _))) => Some(head)
  case Fix(None)            => None
}
```

---

## Cost of `Fix`

```scala
def headOpt(list:      List): Option[Int] = list match {
  case Cons(     head, _)   => Some(head)
  case Nil                  => None
}
```

---

## Cost of `Fix`

```scala
val list: FixedList =
  Fix[ListF](Some((1,
    Fix[ListF](Some((2,
      Fix[ListF](Some((3,
        Fix[ListF](None)
      )))
    )))
  )))
```

---

## Cost of `Fix`

```scala
val list:      List =
  Cons(            1,
    Cons(            2,
      Cons(            3,
        Nil
      )
    )
  )
```

---

## Key takeaways

Using `Fix` makes:

--

* the hard case easier.
--

* the easy case harder.
--

* little sense.

---

class: center, middle

# Generative Recursion

---

## Creating lists

```scala
def range(
  from: Int
): List = {
  if(from > 0) Cons(from, range(from - 1))
  else         Nil
}
```

```scala
mkString(
  range(3)
)
// res26: String = 3 :: 2 :: 1 :: nil
```

---

class: center, middle

# Generalised generative recursion

---

## Generalising `range`

```scala
def range(
  from: Int
): List = {
  if(from > 0) Cons(from, range(from - 1))
  else         Nil
}
```

---

## Generalising `range`

```scala
def recurse(
  from: Int
): List = {
  if(from > 0) Cons(from, recurse(from - 1))
  else         Nil
}
```

---

## Generalising `range`

```scala
def recurse(
  from     : Int,
  predicate: Int => Boolean
): List = {
  if(predicate(from)) Cons(from, recurse(from - 1, predicate))
  else                Nil
}
```

---

## Generalising `range`

```scala
def recurse(
  from     : Int,
  update   : Int => (Int, Int),
  predicate: Int => Boolean
): List = {
  if(predicate(from))  {
    val (state, next) = update(from)
    Cons(state, recurse(next, update, predicate))
  }
  else Nil
}
```

---

## Generalising `range`

```scala
def recurse[A](
  from     : A,
  update   : A => (Int, A),
  predicate: A => Boolean
): List = {
  if(predicate(from)) {
    val (state, next) = update(from)
    Cons(state, recurse(next, update, predicate))
  }
  else Nil
}
```

---

## Generalising `range`

```scala
def recurse[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  from    : A
): List = {
  if(predicate(from)) {
    val (state, next) = update(from)
    Cons(state, recurse(update, predicate)(next))
  }
  else Nil
}
```

---

## Generalising `range`

```scala
def recurse[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  from    : A
): List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop(from)
}
```

---

## Generalising `range`

```scala
def unfold[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  from    : A
): List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop(from)
}
```

---

## `range` as an unfold

```scala
val range: Int => List =
  unfold(
    update    = (a: Int) => (a, a - 1),
    predicate = (a: Int) => a > 0
  )
```

```scala
mkString(range(3))
// res27: String = 3 :: 2 :: 1 :: nil
```

---

class: center, middle

# Generalised unfold

---

## Generalising `unfold`

```scala
def unfold[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  start    : A
): List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop(start)
}
```

---

## Generalising `unfold`

```scala
def unfold[A](
  update   : A => (Int, A),
  predicate: A => Boolean
): A => List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop
}
```

---

## Generalising `unfold`

```scala
def unfold[A](
  update: A => Option[(Int, A)]
): A => List = {

  def loop(curr: A): List = update(curr) match {
    case Some((head, state)) => Cons(head, loop(state))
    case None                => Nil
  }

  loop
}
```

---

## Generalising `unfold`

```scala
def unfold[A](
  update: A => Option[(Int, A)],
  embed : Option[(Int, List)] => List
): A => List = {

  def loop(curr: A): List = embed(update(curr) match {
    case Some((head, state)) => Some((head, loop(state)))
    case None                => None
  })

  loop
}
```

---

## Generalising `unfold`

```scala
val embedList: Option[(Int, List)] => List =
  _ match {
    case Some((head, tail)) => Cons(head, tail)
    case None               => Nil
  }
```

---

## Generalising `unfold`

```scala
def unfold[A](
  update: A => ListF[A],
  embed : ListF[List] => List
): A => List = {

  def loop(curr: A): List = embed(update(curr) match {
    case Some((head, state)) => Some((head, loop(state)))
    case None                => None
  })

  loop
}
```

---

## Generalising `unfold`

```scala
val embedList: ListF[List] => List =
  _ match {
    case Some((head, tail)) => Cons(head, tail)
    case None               => Nil
  }
```

---

## Generalising `unfold`

```scala
def unfold[A](
  update: A => ListF[A],
  embed : ListF[List] => List
): A => List = {

  def loop(curr: A): List =
    embed(fmap(update(curr), loop))

  loop
}
```

---

## Generalising `unfold`

```scala
def unfold[F[_]: Functor, A](
  update: A => F[A],
  embed : F[List] => List
): A => List = {

  def loop(curr: A): List =
    embed(fmap(update(curr), loop))

  loop
}
```

---

## Generalising `unfold`

```scala
def unfold[F[_]: Functor, A, B](
  update: A => F[A],
  embed : F[B] => B
): A => B = {

  def loop(curr: A): B =
    embed(fmap(update(curr), loop))

  loop
}
```

---

## Anamorphism

```scala
def ana[F[_]: Functor, A, B](
  update: A => F[A],
  embed : F[B] => B
): A => B = {

  def loop(curr: A): B =
    embed(fmap(update(curr), loop))

  loop
}
```

---

## Anamorphism

```scala
def ana[F[_]: Functor, A, B](
  coAlgebra: A => F[A],
  embed    : F[B] => B
): A => B = {

  def loop(curr: A): B =
    embed(fmap(coAlgebra(curr), loop))

  loop
}
```

---

## `range` as an ana

```scala
val rangeCoAlgebra: Int => ListF[Int] = i => {
  if(i > 0) Some((i, i - 1))
  else      None
}

val range: Int => List = ana(rangeCoAlgebra, embedList)
```

```scala
mkString(range(3))
// res28: String = 3 :: 2 :: 1 :: nil
```

---

class: center, middle

# Reducing the boilerplate, again

---

## Embedding `Fix`

```scala
def embedFix[F[_]](value: F[Fix[F]]): Fix[F] =
  Fix(value)
```

---

## Specialised `ana` for `Fix`

```scala
def ana[F[_]: Functor, A, B](
  coAlgebra: A => F[A],
  embed    : F[B] => B
): A => B = {

  def loop(curr: A): B =
    embed(fmap(coAlgebra(curr), loop))

  loop
}
```

---

## Specialised `ana` for `Fix`

```scala
def anaFix[F[_]: Functor, A, B](
  coAlgebra: A => F[A],
  embed    : F[B] => B
): A => B = {

  def loop(curr: A): B =
    embed(fmap(coAlgebra(curr), loop))

  loop
}
```

---

## Specialised `ana` for `Fix`

```scala
def anaFix[F[_]: Functor, A](
  coAlgebra: A => F[A],
  embed    : F[Fix[F]] => Fix[F]
): A => Fix[F] = {

  def loop(curr: A): Fix[F] =
    embed(fmap(coAlgebra(curr), loop))

  loop
}
```

---

## Specialised `ana` for `Fix`

```scala
def anaFix[F[_]: Functor, A](
  coAlgebra: A => F[A]
): A => Fix[F] = {

  def loop(curr: A): Fix[F] =
    Fix((fmap(coAlgebra(curr), loop)))

  loop
}
```

---

## Range in terms of `anaFix`

```scala
val rangeFix: Int => FixedList =
  anaFix(rangeCoAlgebra)
```

```scala
rangeFix(3)
// res29: FixedList = Fix(Some((3,Fix(Some((2,Fix(Some((1,Fix(None))))))))))
```

---

class: center, middle

# Generalised generalised folds!

---

```scala
val factorial: Int => Int =
  range andThen product
```

```scala
factorial(3)
// res30: Int = 6
```

---

```scala
val factorial: Int => Int =
  cata(productAlgebra, rangeCoAlgebra)
```

```scala
factorial(3)
// res31: Int = 6
```

---

class: center, middle

# Questions?

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

[@NicolasRinaudo]:https://twitter.com/NicolasRinaudo
[Besedo]:https://twitter.com/besedo_official

    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
          highlightStyle: 'github',
          highlightSpans: true,
          highlightLines: true
      });
    </script>
  </body>
</html>
