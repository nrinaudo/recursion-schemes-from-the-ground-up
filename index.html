<!DOCTYPE html>
<html>
    <head>
        <title>Recursion schemes from the ground up</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link rel="stylesheet" type="text/css" href="css/style.css"/>
    </head>
    <body>
        <textarea id="source">
class: center, middle

# Recursion schemes from the ground up

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

---

class: center, middle

# Recursive Data Types

---

## `List`

```scala
sealed trait List

case class Cons(
  head: Int,
  tail: List
) extends List

case object Nil extends List
```

.center[![Cons List](img/list.svg)]

---

## `List`

```scala
*sealed trait List

case class Cons(
  head: Int,
  tail: List
) extends List

case object Nil extends List
```

.center[![Cons List](img/list.svg)]

---

## `List`

```scala
sealed trait List

*case class Cons(
* head: Int,
* tail: List
*) extends List

case object Nil extends List
```

.center[![Cons](img/list-1.svg)]

---

## `List`

```scala
sealed trait List

case class Cons(
  head: Int,
  tail: List
) extends List

*case object Nil extends List
```

.center[![Nil](img/list-nil.svg)]

---

## `List`

```scala
sealed trait List

*case class Cons(
* head: Int,
* tail: List
*) extends List

case object Nil extends List
```

.center[![Cons](img/list-1.svg)]

---

## `List`

```scala
sealed trait List

case class Cons(
  `head: Int`,
  tail: List
) extends List

case object Nil extends List
```

.center[![Cons](img/list-1-head.svg)]

---

## `List`

```scala
sealed trait List

case class Cons(
  head: Int,
  `tail: List`
) extends List

case object Nil extends List
```

.center[![Cons](img/list-1-tail.svg)]

---

## `List`

```scala
sealed trait List

case class Cons(
  head: Int,
  `tail: List`
) extends List

case object Nil extends List
```

.center[![Nil](img/list-nil.svg)]

---

## `List`

```scala
sealed trait List

case class Cons(
  head: Int,
  tail: List
) extends List

case object Nil extends List
```

```scala
val ints: List = Cons(1, Cons(2, Cons(3, Nil)))
```

---

## `List`

```scala
sealed trait List

case class Cons(
  head: Int,
  tail: List
) extends List

case object Nil extends List
```

```scala
val `ints`: List = Cons(`1`, Cons(`2`, Cons(`3`, Nil)))
```

---

class: center, middle

# Structural Recursion

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints) = ???
```

.center[![List product](img/list.svg)]

---

## Product

```scala
def product(
  `values: List`
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints) = ???
```

.center[![List product](img/list.svg)]

---

## Product

```scala
def product(
  values: List
): `Int` =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints) = ???
```

.center[![List product](img/list.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  `values match` {
    case Nil              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints) = ???
```

.center[![List product: 1](img/list-product-1-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case `Cons(head, tail)` => head * product(tail)
  }
```

```scala
product(ints) = ???
```

.center[![List product: 1](img/list-product-1-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => `head` * product(tail)
  }
```

```scala
product(ints) = `1` * ???
```

.center[![List product: 1](img/list-product-1-head-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head `*` product(tail)
  }
```

```scala
product(ints) = 1 `*` ???
```

.center[![List product: 1](img/list-product-1-tail-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head * `product(tail)`
  }
```

```scala
product(ints) = 1 * `???`
```

.center[![List product](img/list-product-1.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  `values match` {
    case Nil              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints) = 1 * ???
```

.center[![List product](img/list-product-2-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case `Cons(head, tail)` => head * product(tail)
  }
```

```scala
product(ints) = 1 * ???
```

.center[![List product](img/list-product-2-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => `head` * product(tail)
  }
```

```scala
product(ints) = 1 * `2` * ???
```

.center[![List product](img/list-product-2-head-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head `*` product(tail)
  }
```

```scala
product(ints) = 1 * 2 `*` ???
```

.center[![List product](img/list-product-2-tail-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head * `product(tail)`
  }
```

```scala
product(ints) = 1 * 2 * `???`
```

.center[![List product](img/list-product-2.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  `values match` {
    case Nil              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints) = 1 * 2 * ???
```

.center[![List product](img/list-product-3-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case `Cons(head, tail)` => head * product(tail)
  }
```

```scala
product(ints) = 1 * 2 * ???
```

.center[![List product](img/list-product-3-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => `head` * product(tail)
  }
```

```scala
product(ints) = 1 * 2 * `3` * ???
```

.center[![List product](img/list-product-3-head-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head `*` product(tail)
  }
```

```scala
product(ints) = 1 * 2 * 3 `*` ???
```

.center[![List product](img/list-product-3-tail-hl.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head * `product(tail)`
  }
```

```scala
product(ints) = 1 * 2 * 3 * `???`
```

.center[![List product](img/list-product-3.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  `values match` {
    case Nil              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints) = 1 * 2 * 3 * ???
```

.center[![List product](img/list-product-3.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case `Nil`              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints) = 1 * 2 * 3 * ???
```

.center[![List product](img/list-product-3.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => `1`
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints) = 1 * 2 * 3 * `1`
```

.center[![List product](img/list-product-3.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints) = `1 * 2 * 3 * 1`
```

.center[![List product](img/list-product-3.svg)]

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints)
// res0: Int = 6
```

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    `case Cons(head, tail)` => head * product(tail)
  }
```

```scala
product(ints)
```

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => 1
    case Cons(head, tail) => `head * product(tail)`
  }
```

```scala
product(ints)
```

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    `case Nil`              => 1
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints)
```

---

## Product

```scala
def product(
  values: List
): Int =
  values match {
    case Nil              => `1`
    case Cons(head, tail) => head * product(tail)
  }
```

```scala
product(ints)
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + mkString(tail)
  }
```

---

## String representation

```scala
def mkString(
  `values: List`
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + mkString(tail)
  }
```

---

## String representation

```scala
def mkString(
  values: List
): `String` =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + mkString(tail)
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Nil              => "nil"
    `case Cons(head, tail)` => head + " :: " + mkString(tail)
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => `head` + " :: " + mkString(tail)
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + `" :: "` + mkString(tail)
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + `mkString(tail)`
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    `case Nil`              => "nil"
    case Cons(head, tail) => head + " :: " + mkString(tail)
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Nil              => `"nil"`
    case Cons(head, tail) => head + " :: " + mkString(tail)
  }
```

---

## String representation

```scala
def mkString(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + mkString(tail)
  }
```

```scala
mkString(ints)
// res1: String = 1 :: 2 :: 3 :: nil
```

---

## Key takeaways

Structural recursion works by:
* pattern matching on the "problem" value
* having a concrete implementation for the base case.
* for all other cases, assuming we have a solution for a smaller problem and complete it.

---

class: center, middle

# Generalised structural recursion

---

## Generalising `mkString`

```scala
def mkString(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + mkString(tail)
  }
```

---

## Generalising `mkString`

```scala
def `mkString`(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + `mkString`(tail)
  }
```

---

## Generalising `mkString`

```scala
def `recurse`(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + `recurse`(tail)
  }
```

---

## Generalising `mkString`

```scala
def recurse(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + recurse(tail)
  }
```

```scala
recurse(ints)
// res2: String = 1 :: 2 :: 3 :: nil
```

---

## Generalising `mkString`

.center[![fold - step 1](img/fold-1.svg)]

---

## Generalising the base case

```scala
def recurse(
  values: List
): String =
  values match {
    case Nil              => `"nil"`
    case Cons(head, tail) => head + " :: " + recurse(tail)
  }
```

---

## Generalising the base case

```scala
def recurse(
  values: List
): String =
  values match {
    case Nil              => "nil"
    case Cons(head, tail) => head + " :: " + recurse(tail)
  }
```

```scala
&#x200B;`val base: String = "nil"`
```

---

## Generalising the base case

```scala
def recurse(
  values: List
): String =
  values match {
    case Nil              => `"nil"`
    case Cons(head, tail) => head + " :: " + recurse(tail)
  }
```

```scala
val base: String = "nil"
```

---

## Generalising the base case

```scala
def recurse(
  values: List
): String =
  values match {
    case Nil              => `base`
    case Cons(head, tail) => head + " :: " + recurse(tail)
  }
```

```scala
val base: String = "nil"
```

---

## Generalising the base case

```scala
def recurse(
  `base  : String`,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => head + " :: " + recurse(tail)
  }
```

---

## Generalising the base case

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => head + " :: " + recurse(`base`, tail)
  }
```

---

## Generalising the base case

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => head + " :: " + recurse(base, tail)
  }
```

```scala
recurse(base, ints)
// res3: String = 1 :: 2 :: 3 :: nil
```

---

## Generalising the base case

.center[![fold - step 2](img/fold-2.svg)]

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => `head + " :: " + recurse(base, tail)`
  }
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => `head` + " :: " + recurse(base, tail)
  }
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => head + " :: " + `recurse(base, tail)`
  }
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => head + " :: " + recurse(base, tail)
  }
```

```scala
*def step(head: Int, tail: String): String =
* head + " :: " + tail
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => `head + " :: " + recurse(base, tail)`
  }
```

```scala
def step(head: Int, tail: String): String =
  head + " :: " + tail
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => `step(head, recurse(base, tail))`
  }
```

```scala
def step(head: Int, tail: String): String =
  head + " :: " + tail
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  `step  : (Int, String) => String,`
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, tail))
  }
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  step  : (Int, String) => String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, `step`, tail))
  }
```

---

## Generalising the step

```scala
def recurse(
  base  : String,
  step  : (Int, String) => String,
  values: List
): String =
  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, step, tail))
  }
```

```scala
recurse(base, step, ints)
// res4: String = 1 :: 2 :: 3 :: nil
```

---

## Generalising the step

.center[![fold - step 3](img/fold-3.svg)]

---

## Generalising the return type

```scala
def recurse(
  base  : `String`,
  step  : (Int, `String`) => `String`,
  values: List
): `String` =
  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, step, tail))
  }
```

---

## Generalising the return type

```scala
def recurse[`A`](
  base  : `A`,
  step  : (Int, `A`) => `A`,
  values: List
): `A` =
  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, step, tail))
  }
```

---

## Generalising the return type

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A =
  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, step, tail))
  }
```

```scala
recurse(base, step, ints)
// res5: String = 1 :: 2 :: 3 :: nil
```

---

## Generalising the return type

.center[![fold - step 4](img/fold-4.svg)]

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A =
  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, `recurse(base, step, tail)`)
  }
```

---

## Simplifying the step

```scala
def recurse[A](
  `base`  : A,
  step  : (Int, A) => A,
  values: List
): A =
  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(`base`, step, tail))
  }
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  `step`  : (Int, A) => A,
  values: List
): A =
  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, `step`, tail))
  }
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A =
* values match {
*   case Nil              => base
*   case Cons(head, tail) => step(head, recurse(base, step, tail))
* }
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
* def loop(curr: List): A =
*   curr match {
*     case Nil              => base
*     case Cons(head, tail) =>
*       step(head, recurse(base, step, tail))
*   }

  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, step, tail))
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) =>
        step(head, `recurse(base, step, tail)`)
    }

  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, step, tail))
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) =>
        step(head, `loop(tail)`)
    }

  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, step, tail))
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  values match {
    case Nil              => base
    case Cons(head, tail) => step(head, recurse(base, step, tail))
  }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

* values match {
*   case Nil              => base
*   case Cons(head, tail) => step(head, recurse(base, step, tail))
* }
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  `loop(values)`
}
```

---

## Simplifying the step

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  values: List
): A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop(values)
}
```

```scala
recurse(base, step, ints)
// res6: String = 1 :: 2 :: 3 :: nil
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A,
  `values: List`
): A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop(`values`)
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  `loop`
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): A = {
* def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): `A` = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): `List => A` = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Dropping parameters

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

```scala
recurse(base, step)(ints)
// res7: String = 1 :: 2 :: 3 :: nil
```

---

## Dropping parameters

```scala
val mkString: List => String =
  recurse(base, step)
```

---

## Dropping parameters

```scala
val `mkString`: List => String =
  recurse(base, step)
```

---

## Dropping parameters

```scala
val mkString: List => String =
  `recurse(base, step)`
```

---

## Dropping parameters

```scala
val mkString: List => String =
  recurse(base, step)
```

```scala
mkString(ints)
// res8: String = 1 :: 2 :: 3 :: nil
```

---

## Naming things

```scala
def recurse[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Naming things

```scala
def `recurse`[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Naming things

```scala
def `fold`[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Naming things

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {
  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

```scala
fold(base, step)(ints)
// res9: String = 1 :: 2 :: 3 :: nil
```

---

## `product` as a fold

```scala
val product: List => Int =
  fold[Int](
    base = 1,
    step = (head, tail) => head * tail

  )
```

---

## `product` as a fold

```scala
val product: List => Int =
  `fold`[Int](
    base = 1,
    step = (head, tail) => head * tail

  )
```

---

## `product` as a fold

```scala
val product: List => Int =
  fold[Int](
    `base = 1`,
    step = (head, tail) => head * tail

  )
```

---

## `product` as a fold

```scala
val product: List => Int =
  fold[Int](
    base = 1,
    `step = (head, tail) => head * tail`

  )
```

---

## `product` as a fold

```scala
val product: List => Int =
  fold[Int](
    base = 1,
    step = (head, tail) => head * tail

  )
```

```scala
product(ints)
// res10: Int = 6
```

---

## `mkString` as a fold

```scala
val mkString: List => String =
  fold[String](
    base = "nil",
    step = (head, tail) => head + " :: " + tail
  )
```

---

## `mkString` as a fold

```scala
val mkString: List => String =
  `fold`[String](
    base = "nil",
    step = (head, tail) => head + " :: " + tail
  )
```

---

## `mkString` as a fold

```scala
val mkString: List => String =
  fold[String](
    `base = "nil"`,
    step = (head, tail) => head + " :: " + tail
  )
```

---

## `mkString` as a fold

```scala
val mkString: List => String =
  fold[String](
    base = "nil",
    `step = (head, tail) => head + " :: " + tail`
  )
```

---

## `mkString` as a fold

```scala
val mkString: List => String =
  fold[String](
    base = "nil",
    step = (head, tail) => head + " :: " + tail
  )
```

```scala
mkString(ints)
// res11: String = 1 :: 2 :: 3 :: nil
```

---

## Key takeaways

TODO

---

class: center, middle

# Generalised folds

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Generalised folds

.center[![Cata step 1](img/cata-1.svg)]

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    curr match {
      case `Nil`              => base
      case `Cons(head, tail)` => step(head, loop(tail))
    }

  loop
}
```

---

## List projection

```scala
val project: List => Option[(Int, List)] =
  _ match {
    case Nil              => None
    case Cons(head, tail) => Some((head, tail))
  }
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    curr match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    `curr` match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    `project(curr)` match {
      case Nil              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case `Nil`              => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case `None`             => base
      case Cons(head, tail) => step(head, loop(tail))
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None             => base
      case `Cons(head, tail)` => step(head, loop(tail))
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => base
      case `Some((head, tail))` => step(head, loop(tail))
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base  : A,
  step  : (Int, A) => A
): List => A = {

  def loop(curr: List): A =
    `project`(curr) match {
      case None               => base
      case Some((head, tail)) => step(head, loop(tail))
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base   : A,
  step   : (Int, A) => A,
  `project: List => Option[(Int, List)]`
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => base
      case Some((head, tail)) => step(head, loop(tail))
    }

  loop
}
```

---

## Abstracting over structure

```scala
def fold[A](
  base   : A,
  step   : (Int, A) => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => base
      case Some((head, tail)) => step(head, loop(tail))
    }

  loop
}
```

```scala
fold(base, step, project)(ints)
// res12: String = 1 :: 2 :: 3 :: nil
```

---

## Abstracting over structure

.center[![Cata step 2](img/cata-2.svg)]

---

## Abstracting over structure

```scala
def fold[A](
* base   : A,
* step   : (Int, A) => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => base
      case Some((head, tail)) => step(head, loop(tail))
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case None               => base
    case Some((head, tail)) => step(head, tail)
  }
```

---

## Simplifying `base` and `step`

```scala
val op: `Option[(Int, String)]` => String =
  _ match {
    case None               => base
    case Some((head, tail)) => step(head, tail)
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => `String` =
  _ match {
    case None               => base
    case Some((head, tail)) => step(head, tail)
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  `_ match` {
    case None               => base
    case Some((head, tail)) => step(head, tail)
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case `None`               => base
    case Some((head, tail)) => step(head, tail)
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case None               => `base`
    case Some((head, tail)) => step(head, tail)
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case None               => `"nil"`
    case Some((head, tail)) => step(head, tail)
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case None               => "nil"
    case `Some((head, tail))` => step(head, tail)
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case None               => "nil"
    case Some((head, tail)) => `step(head, tail)`
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case None               => "nil"
    case Some((head, tail)) => `head + " :: " + tail`
  }
```

---

## Simplifying `base` and `step`

```scala
val op: Option[(Int, String)] => String =
  _ match {
    case None               => "nil"
    case Some((head, tail)) => head + " :: " + tail
  }
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
* base   : A,
* step   : (Int, A) => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => base
      case Some((head, tail)) => step(head, loop(tail))
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
* op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => base
      case Some((head, tail)) => step(head, loop(tail))
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => `base`
      case Some((head, tail)) => step(head, loop(tail))
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => `op(None)`
      case Some((head, tail)) => step(head, loop(tail))
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => op(None)
      case Some((head, tail)) => `step(head, loop(tail))`
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => op(None)
      case Some((head, tail)) => `op(Some((head, loop(tail))))`
    }

  loop
}
```

---

## Simplifying `base` and `step`

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => op(None)
      case Some((head, tail)) => op(Some((head, loop(tail))))
    }

  loop
}
```

```scala
fold(op, project)(ints)
// res13: String = 1 :: 2 :: 3 :: nil
```

---

## Simplifying `base` and `step`

.center[![Cata step 3](img/cata-3.svg)]


---

## TODO

Graph that maps from `Nil -> None` and `Cons(head, tail) -> Some((head, tail))`

Graph that maps from `Some((head, tail)) -> head + " :: " + tail` and `Nil -> "nil"`

---

## Intermediate representation

```scala
def fold[A](
  op     : `Option[(Int, A)]` => A,
  project: List => `Option[(Int, List)]`
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => op(None)
      case Some((head, tail)) => op(Some((head, loop(tail))))
    }

  loop
}
```

---

## Intermediate representation

```scala
type ListF[A] = Option[(Int, A)]
```

---

## Intermediate representation

```scala
type `ListF[A]` = Option[(Int, A)]
```

---

## Intermediate representation

```scala
type ListF[A] = `Option[(Int, A)]`
```

---

## Intermediate representation

```scala
def fold[A](
  op     : Option[(Int, A)] => A,
  project: List => Option[(Int, List)]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => op(None)
      case Some((head, tail)) => op(Some((head, loop(tail))))
    }

  loop
}
```


---

## Intermediate representation

```scala
def fold[A](
  op     : `Option[(Int, A)]` => A,
  project: List => `Option[(Int, List)]`
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => op(None)
      case Some((head, tail)) => op(Some((head, loop(tail))))
    }

  loop
}
```

---

## Intermediate representation

```scala
def fold[A](
  op     : `ListF[A]` => A,
  project: List => `ListF[List]`
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => op(None)
      case Some((head, tail)) => op(Some((head, loop(tail))))
    }

  loop
}
```

---

## Intermediate representation

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => op(None)
      case Some((head, tail)) => op(Some((head, loop(tail))))
    }

  loop
}
```

```scala
fold(op, project)(ints)
// res14: String = 1 :: 2 :: 3 :: nil
```

---

## Intermediate representation

.center[![Cata step 4](img/cata-4.svg)]

---

## Intermediate representation

```scala
val project: List => ListF[List] =
  _ match {
    case Nil              => None
    case Cons(head, tail) => Some((head, tail))
  }
```

---

## Intermediate representation

```scala
val project: List => ListF[List] =
  _ match {
    case `Nil`              => `None`
    case Cons(head, tail) => Some((head, tail))
  }
```

---

## Intermediate representation

```scala
val project: List => ListF[List] =
  _ match {
    case Nil              => None
    case `Cons(head, tail)` => `Some((head, tail))`
  }
```


---

## Intermediate representation

```scala
val op: ListF[String] => String =
  _ match {
    case None               => "nil"
    case Some((head, tail)) => head + " :: " + tail
  }
```

---

## Intermediate representation

```scala
val op: ListF[String] => String =
  _ match {
    case `None`               => `"nil"`
    case Some((head, tail)) => head + " :: " + tail
  }
```

---

## Intermediate representation

```scala
val op: ListF[String] => String =
  _ match {
    case None               => "nil"
    case `Some((head, tail))` => `head + " :: " + tail`
  }
```

---

## Moving `op`

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => op(None)
      case Some((head, tail)) => op(Some((head, loop(tail))))
    }

  loop
}
```

---

## Moving `op`

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    project(curr) match {
      case None               => `op`(None)
      case Some((head, tail)) => `op`(Some((head, loop(tail))))
    }

  loop
}
```

---

## Moving `op`

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    `op`(project(curr) match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    })

  loop
}
```

---

## Moving `op`

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    })

  loop
}
```

```scala
fold(op, project)(ints)
// res15: String = 1 :: 2 :: 3 :: nil
```

---

## Moving `op`

.center[![Cata step 5](img/cata-5.svg)]

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
*     case None               => None
*     case Some((head, tail)) => Some((head, loop(tail)))
    })

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case `None`               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    })

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case None               => `None`
      case Some((head, tail)) => Some((head, loop(tail)))
    })

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case None               => None
      case `Some((head, tail))` => Some((head, loop(tail)))
    })

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case None               => None
      case Some((head, tail)) => `Some((head, loop(tail)))`
    })

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(project(curr) match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    })

* def recurse(curr: ListF[List]): ListF[A] =
*   curr match {
*     case None               => None
*     case Some((head, tail)) => Some((head, loop(tail)))
*   }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
*   op(project(curr) match {
*     case None               => None
*     case Some((head, tail)) => Some((head, loop(tail)))
*   })

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(`recurse`(project(curr)))

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: `ListF[List]`): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List]): `ListF[A]` =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, `loop(tail)`))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: `List`): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): `A` =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List]): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List], `f: List => A`): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, loop(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, `loop`(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr)))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, `f`(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), `loop`))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, f(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, f(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: `ListF[List]`, f: List => A): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, f(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: `List => A`): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, f(tail)))
    }

  loop
}
```

---

## Generalising recursion

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): `ListF[A]` =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, f(tail)))
    }

  loop
}
```

---

TODO : couple of slides to explain `Functor`

---

## Functor

```scala
trait Functor[F[_]] {
  def map[A, B](fa: F[A], f: A => B): F[B]
}
```

---

## Functor

```scala
def fmap[F[_], A, B](
  fa  : F[A],
  f   :  A => B
)(implicit
  functor: Functor[F]
): F[B] =
  functor.map(fa, f)
```

---

## Functor

```scala
implicit val listFFunctor = new Functor[ListF] {
  override def map[A, B](
    fa: ListF[A],
    f: A => B
  ) =
    fa match {
      case None               => None
      case Some((head, tail)) => Some((head, f(tail)))
    }
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    curr match {
      case None               => None
      case Some((head, tail)) => Some((head, f(tail)))
    }

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
*   curr match {
*     case None               => None
*     case Some((head, tail)) => Some((head, f(tail)))
*   }

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(recurse(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    `fmap(curr, f)`

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(`recurse`(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    fmap(curr, f)

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(`fmap`(project(curr), loop))

  def recurse(curr: ListF[List], f: List => A): ListF[A] =
    fmap(curr, f)

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

* def recurse(curr: ListF[List], f: List => A): ListF[A] =
*   fmap(curr, f)

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Using Functor

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

```scala
fold(op, project)(ints)
// res16: String = 1 :: 2 :: 3 :: nil
```

---

## Intermediate representation

.center[![Cata step 6](img/cata-6.svg)]

---

## Abstracting over `ListF`

```scala
def fold[A](
  op     : `ListF`[A] => A,
  project: List => `ListF`[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `ListF`

```scala
def fold[A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(`fmap`(project(curr), loop))

  loop
}
```

---

## Abstracting over `ListF`

```scala
def fold[`F[_]: Functor`, A](
  op     : ListF[A] => A,
  project: List => ListF[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `ListF`

```scala
def fold[F[_]: Functor, A](
  op     : `ListF`[A] => A,
  project: List => `ListF`[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `ListF`

```scala
def fold[F[_]: Functor, A](
  op     : `F`[A] => A,
  project: List => `F`[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `ListF`

```scala
def fold[F[_]: Functor, A](
  op     : F[A] => A,
  project: List => F[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

```scala
fold(op, project).apply(ints)
// res17: String = 1 :: 2 :: 3 :: nil
```

---

## Abstracting over `ListF`

.center[![Cata step 7](img/cata-7.svg)]


---

## Abstracting over `List`

```scala
def fold[F[_]: Functor, A](
  op     : F[A] => A,
  project: `List` => F[`List`]
): `List` => A = {

  def loop(curr: `List`): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `List`

```scala
def fold[F[_]: Functor, A, `B`](
  op     : F[A] => A,
  project: List => F[List]
): List => A = {

  def loop(curr: List): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `List`

```scala
def fold[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: `List` => F[`List`]
): `List` => A = {

  def loop(curr: `List`): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `List`

```scala
def fold[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: `B` => F[`B`]
): `B` => A = {

  def loop(curr: `B`): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Abstracting over `List`

```scala
def fold[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    op(fmap(project(curr), loop))

  loop
}
```

```scala
fold(op, project).apply(ints)
// res18: String = 1 :: 2 :: 3 :: nil
```

---

## Abstracting over `List`

.center[![Cata step 8](img/cata-8.svg)]


---

## Naming things

```scala
def `fold`[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Naming things

```scala
def `cata`[F[_]: Functor, A, B](
  op     : F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    op(fmap(project(curr), loop))

  loop
}
```

---

## Naming things

```scala
def cata[F[_]: Functor, A, B](
  `op`     : F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    `op`(fmap(project(curr), loop))

  loop
}
```

---

## Naming things

```scala
def cata[F[_]: Functor, A, B](
  `algebra`: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    `algebra`(fmap(project(curr), loop))

  loop
}
```

---

## Naming things

```scala
def cata[`F[_]: Functor`, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## Naming things

```scala
def cata[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

```scala
cata(op, project).apply(ints)
// res19: String = 1 :: 2 :: 3 :: nil
```

---

## Naming things

.center[![Cata step 9](img/cata-9.svg)]


---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case None               => 1
    case Some((head, tail)) => head * tail
  }

val product: List => Int = cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val `productAlgebra: ListF[Int] => Int` =
  _ match {
    case None               => 1
    case Some((head, tail)) => head * tail
  }

val product: List => Int = cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case `None`               => 1
    case Some((head, tail)) => head * tail
  }

val product: List => Int = cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case None               => `1`
    case Some((head, tail)) => head * tail
  }

val product: List => Int = cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case None               => 1
    case `Some((head, tail))` => head * tail
  }

val product: List => Int = cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case None               => 1
    case Some((head, tail)) => `head * tail`
  }

val product: List => Int = cata(productAlgebra, project)
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case None               => 1
    case Some((head, tail)) => head * tail
  }

val product: List => Int = `cata(productAlgebra, project)`
```

---

## `product` as a cata

```scala
val productAlgebra: ListF[Int] => Int =
  _ match {
    case None               => 1
    case Some((head, tail)) => head * tail
  }

val product: List => Int = cata(productAlgebra, project)
```

```scala
product(ints)
// res20: Int = 6
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case None               => "nil"
    case Some((head, tail)) => head + " :: " + tail
  }

val mkString: List => String = cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val `mkStringAlgebra: ListF[String] => String` =
  _ match {
    case None               => "nil"
    case Some((head, tail)) => head + " :: " + tail
  }

val mkString: List => String = cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case `None`               => "nil"
    case Some((head, tail)) => head + " :: " + tail
  }

val mkString: List => String = cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case None               => `"nil"`
    case Some((head, tail)) => head + " :: " + tail
  }

val mkString: List => String = cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case None               => "nil"
    case `Some((head, tail))` => head + " :: " + tail
  }

val mkString: List => String = cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case None               => "nil"
    case Some((head, tail)) => `head + " :: " + tail`
  }

val mkString: List => String = cata(mkStringAlgebra, project)
```

---

## `mkString` as a cata

```scala
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case None               => "nil"
    case Some((head, tail)) => head + " :: " + tail
  }

val mkString: List => String = `cata(mkStringAlgebra, project)`
```

---

## `mkString` as a cata

```scalatut:silent
val mkStringAlgebra: ListF[String] => String =
  _ match {
    case None               => "nil"
    case Some((head, tail)) => head + " :: " + tail
  }

val mkString: List => String = cata(mkStringAlgebra, project)
```

```scala
mkString(ints)
// res21: String = 1 :: 2 :: 3 :: nil
```

---

class: center, middle

# What about non-`List`?

---

## Tree

```scala
sealed trait Tree

case class Node(
  left : Tree,
  value: Int,
  right: Tree
) extends Tree

case object Leaf extends Tree
```

```scala
val intTree = Node(
  Node(
    Node(Leaf, 1, Leaf),
    2,
    Node(Leaf, 3, Leaf)
  ),
  4,
  Leaf
)
// intTree: Node = Node(Node(Node(Leaf,1,Leaf),2,Node(Leaf,3,Leaf)),4,Leaf)
```

---

## Pattern functor

```scala
sealed trait TreeF[+A]

case class NodeF[A](
  left : A,
  value: Int,
  right: A
) extends TreeF[A]

case object LeafF extends TreeF[Nothing]
```

---

## Projection

```scala
def projectTree: Tree => TreeF[Tree] =
  _ match {
    case Leaf          => LeafF
    case Node(l, v ,r) => NodeF(l, v, r)
  }
```

---

## Functor instance

```scala
implicit val treeFFunctor: Functor[TreeF] = new Functor[TreeF] {
  override def map[A, B](tree: TreeF[A], f: A => B) = tree match {
    case LeafF          => LeafF
    case NodeF(l, v, r) => NodeF(f(l), v, f(r))
  }
}
```

---

## Tree depth

```scala
val depthAlgebra: TreeF[Int] => Int =
  _ match {
    case LeafF                           => 0
    case NodeF(leftDepth, _, rightDepth) => math.max(
      leftDepth + 1,
      rightDepth + 1
    )
  }

val depth: Tree => Int = cata(depthAlgebra, projectTree)
```

```scala
depth(intTree)
// res22: Int = 3
```

---

## Key takeaways

* `cata` works just fine with `Tree`.
* it involves a lot of busywork though...

---

class: center, middle

# Reducing the boilerplate

---

## `List` in terms of `ListF`

```scala
type NotList = ListF[???]
```

---

## `List` in terms of `ListF`

```scala
type NotList = ListF[`???`]
```

---

## `List` in terms of `ListF`

```scala
type NotList = ListF[`ListF[???]`]
```

---

## `List` in terms of `ListF`

```scala
type NotList = ListF[`NotList`]
```

---

## `List` in terms of `ListF`

```scala
type NotList = ListF[NotList]
//        type NotList = ListF[NotList]
//                             ^
// On line 2: error: illegal cyclic reference involving type NotList
```

---

## `List` in terms of `ListF`

```scala
case class NotList(value: ListF[NotList])
```

---

## `List` in terms of `ListF`

```scala
case class NotList(value: `ListF`[NotList])
```

---

## `List` in terms of `ListF`

```scala
case class NotList[`F[_]`](value: ListF[NotList])
```

---

## `List` in terms of `ListF`

```scala
case class NotList[F[_]](value: `ListF`[NotList])
```

---

## `List` in terms of `ListF`

```scala
case class NotList[F[_]](value: `F`[NotList])
```

---

## `List` in terms of `ListF`

```scala
case class NotList[F[_]](value: F[`NotList`])
```

---

## `List` in terms of `ListF`

```scala
case class NotList[F[_]](value: F[NotList[`F`]])
```

---

## `List` in terms of `ListF`

```scala
case class NotList[F[_]](value: F[NotList[F]])
```

---

## Naming things

```scala
case class `NotList`[F[_]](value: F[`NotList`[F]])
```

---

## Naming things

```scala
case class `Fix`[F[_]](value: F[`Fix`[F]])
```

---

## Naming things

```scala
case class Fix[F[_]](value: F[Fix[F]])
```

---

## `List` in terms of `Fix`

```scala
type FixedList = Fix[ListF]
```

---

## `List` in terms of `Fix`

```scala
val fixedInts: FixedList =
  Fix[ListF](Some((1,
    Fix[ListF](Some((2,
      Fix[ListF](Some((3,
        Fix[ListF](None)
      )))
    )))
  )))
```

---

## Projecting `Fix`

```scala
val project: List => ListF[List] =
  _ match {
    case Nil              => None
    case Cons(head, tail) => Some((head, tail))
  }
```

---

## Projecting `Fix`

```scala
val projectFix: FixedList => ListF[FixedList] =
  _ match {
    case Fix(value) => value
    case Fix(value) => value
  }
```

---

## TODO

Show `project` in terms of `FixedList`

---

## Specialised `cata` for `Fix`

```scala
def cata[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def `cata`[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def `cataFix`[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: B => F[B]
): B => A = {

  def loop(curr: B): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A, `B`](
  algebra: F[A] => A,
  project: `B` => F[`B`]
): `B` => A = {

  def loop(curr: `B`): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A, B](
  algebra: F[A] => A,
  project: `Fix[F]` => F[`Fix[F]`]
): `Fix[F]` => A = {

  def loop(curr: `Fix[F]`): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A, `B`](
  algebra: F[A] => A,
  project: Fix[F] => F[Fix[F]]
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
  project: Fix[F] => F[Fix[F]]
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(project(curr), loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
  project: Fix[F] => F[Fix[F]]
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(`project(curr)`, loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
  project: Fix[F] => F[Fix[F]]
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(`curr.value`, loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A,
  `project: Fix[F] => F[Fix[F]]`
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(curr.value, loop))

  loop
}
```

---

## Specialised `cata` for `Fix`

```scala
def cataFix[F[_]: Functor, A](
  algebra: F[A] => A
): Fix[F] => A = {

  def loop(curr: Fix[F]): A =
    algebra(fmap(curr.value, loop))

  loop
}
```

---

TODO : add the mkString examples on each tut:silent

---

## `product` in terms of `cataFix`

```scala
val productFix: FixedList => Int =
  cataFix(productAlgebra)
```

--

```scala
productFix(fixedInts)
// res23: Int = 6
```

---

## `mkString` in terms of `cataFix`

```scala
val mkStringFix: FixedList => String =
  cataFix(mkStringAlgebra)
```

--

```scala
mkStringFix(fixedInts)
// res24: String = 1 :: 2 :: 3 :: nil
```

---

## Cost of `Fix`

```scala
def headOpt(list: FixedList): Option[Int] = list match {
  case Fix(Some((head, _))) => Some(head)
  case Fix(None)            => None
}
```

---

## Cost of `Fix`

```scala
def headOpt(list:      List): Option[Int] = list match {
  case Cons(     head, _)   => Some(head)
  case Nil                  => None
}
```

---

## Cost of `Fix`

```scala
val list: FixedList =
  Fix[ListF](Some((1,
    Fix[ListF](Some((2,
      Fix[ListF](Some((3,
        Fix[ListF](None)
      )))
    )))
  )))
```

---

## Cost of `Fix`

```scala
val list:      List =
  Cons(            1,
    Cons(            2,
      Cons(            3,
        Nil
      )
    )
  )
```

---

## Key takeaways

Using `Fix` makes:

--

* the hard case easier.
--

* the easy case harder.
--

* little sense.

---

class: center, middle

# Generative Recursion

---

## Creating lists

```scala
def range(
  from: Int
): List = {
  if(from > 0) Cons(from, range(from - 1))
  else         Nil
}
```

```scala
mkString(
  range(3)
)
// res25: String = 3 :: 2 :: 1 :: nil
```

---

class: center, middle

# Generalised generative recursion

---

## Generalising `range`

```scala
def range(
  from: Int
): List = {
  if(from > 0) Cons(from, range(from - 1))
  else         Nil
}
```

---

## Generalising `range`

```scala
def recurse(
  from: Int
): List = {
  if(from > 0) Cons(from, recurse(from - 1))
  else         Nil
}
```

---

## Generalising `range`

```scala
def recurse(
  from     : Int,
  predicate: Int => Boolean
): List = {
  if(predicate(from)) Cons(from, recurse(from - 1, predicate))
  else                Nil
}
```

---

## Generalising `range`

```scala
def recurse(
  from     : Int,
  update   : Int => (Int, Int),
  predicate: Int => Boolean
): List = {
  if(predicate(from))  {
    val (state, next) = update(from)
    Cons(state, recurse(next, update, predicate))
  }
  else Nil
}
```

---

## Generalising `range`

```scala
def recurse[A](
  from     : A,
  update   : A => (Int, A),
  predicate: A => Boolean
): List = {
  if(predicate(from)) {
    val (state, next) = update(from)
    Cons(state, recurse(next, update, predicate))
  }
  else Nil
}
```

---

## Generalising `range`

```scala
def recurse[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  from    : A
): List = {
  if(predicate(from)) {
    val (state, next) = update(from)
    Cons(state, recurse(update, predicate)(next))
  }
  else Nil
}
```

---

## Generalising `range`

```scala
def recurse[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  from    : A
): List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop(from)
}
```

---

## Generalising `range`

```scala
def unfold[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  from    : A
): List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop(from)
}
```

---

## `range` as an unfold

```scala
val range: Int => List =
  unfold(
    update    = (a: Int) => (a, a - 1),
    predicate = (a: Int) => a > 0
  )
```

```scala
mkString(range(3))
// res26: String = 3 :: 2 :: 1 :: nil
```

---

class: center, middle

# Generalised unfold

---

## Generalising `unfold`

```scala
def unfold[A](
  update   : A => (Int, A),
  predicate: A => Boolean
)(
  start    : A
): List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop(start)
}
```

---

## Generalising `unfold`

```scala
def unfold[A](
  update   : A => (Int, A),
  predicate: A => Boolean
): A => List = {

  def loop(curr: A): List =
    if(predicate(curr)) {
      val (state, next) = update(curr)
      Cons(state, loop(next))
    }
    else Nil

  loop
}
```

---

## Generalising `unfold`

```scala
def unfold[A](
  update: A => Option[(Int, A)]
): A => List = {

  def loop(curr: A): List = update(curr) match {
    case Some((head, state)) => Cons(head, loop(state))
    case None                => Nil
  }

  loop
}
```

---

## Generalising `unfold`

```scala
def unfold[A](
  update: A => Option[(Int, A)],
  embed : Option[(Int, List)] => List
): A => List = {

  def loop(curr: A): List = embed(update(curr) match {
    case Some((head, state)) => Some((head, loop(state)))
    case None                => None
  })

  loop
}
```

---

## Generalising `unfold`

```scala
val embedList: Option[(Int, List)] => List =
  _ match {
    case Some((head, tail)) => Cons(head, tail)
    case None               => Nil
  }
```

---

## Generalising `unfold`

```scala
def unfold[A](
  update: A => ListF[A],
  embed : ListF[List] => List
): A => List = {

  def loop(curr: A): List = embed(update(curr) match {
    case Some((head, state)) => Some((head, loop(state)))
    case None                => None
  })

  loop
}
```

---

## Generalising `unfold`

```scala
val embedList: ListF[List] => List =
  _ match {
    case Some((head, tail)) => Cons(head, tail)
    case None               => Nil
  }
```

---

## Generalising `unfold`

```scala
def unfold[A](
  update: A => ListF[A],
  embed : ListF[List] => List
): A => List = {

  def loop(curr: A): List =
    embed(fmap(update(curr), loop))

  loop
}
```

---

## Generalising `unfold`

```scala
def unfold[F[_]: Functor, A](
  update: A => F[A],
  embed : F[List] => List
): A => List = {

  def loop(curr: A): List =
    embed(fmap(update(curr), loop))

  loop
}
```

---

## Generalising `unfold`

```scala
def unfold[F[_]: Functor, A, B](
  update: A => F[A],
  embed : F[B] => B
): A => B = {

  def loop(curr: A): B =
    embed(fmap(update(curr), loop))

  loop
}
```

---

## Anamorphism

```scala
def ana[F[_]: Functor, A, B](
  update: A => F[A],
  embed : F[B] => B
): A => B = {

  def loop(curr: A): B =
    embed(fmap(update(curr), loop))

  loop
}
```

---

## Anamorphism

```scala
def ana[F[_]: Functor, A, B](
  coAlgebra: A => F[A],
  embed    : F[B] => B
): A => B = {

  def loop(curr: A): B =
    embed(fmap(coAlgebra(curr), loop))

  loop
}
```

---

## `range` as an ana

```scala
val rangeCoAlgebra: Int => ListF[Int] = i => {
  if(i > 0) Some((i, i - 1))
  else      None
}

val range: Int => List = ana(rangeCoAlgebra, embedList)
```

```scala
mkString(range(3))
// res27: String = 3 :: 2 :: 1 :: nil
```

---

class: center, middle

# Reducing the boilerplate, again

---

## Embedding `Fix`

```scala
def embedFix[F[_]](value: F[Fix[F]]): Fix[F] =
  Fix(value)
```

---

## Specialised `ana` for `Fix`

```scala
def ana[F[_]: Functor, A, B](
  coAlgebra: A => F[A],
  embed    : F[B] => B
): A => B = {

  def loop(curr: A): B =
    embed(fmap(coAlgebra(curr), loop))

  loop
}
```

---

## Specialised `ana` for `Fix`

```scala
def anaFix[F[_]: Functor, A, B](
  coAlgebra: A => F[A],
  embed    : F[B] => B
): A => B = {

  def loop(curr: A): B =
    embed(fmap(coAlgebra(curr), loop))

  loop
}
```

---

## Specialised `ana` for `Fix`

```scala
def anaFix[F[_]: Functor, A](
  coAlgebra: A => F[A],
  embed    : F[Fix[F]] => Fix[F]
): A => Fix[F] = {

  def loop(curr: A): Fix[F] =
    embed(fmap(coAlgebra(curr), loop))

  loop
}
```

---

## Specialised `ana` for `Fix`

```scala
def anaFix[F[_]: Functor, A](
  coAlgebra: A => F[A]
): A => Fix[F] = {

  def loop(curr: A): Fix[F] =
    Fix((fmap(coAlgebra(curr), loop)))

  loop
}
```

---

## Range in terms of `anaFix`

```scala
val rangeFix: Int => FixedList =
  anaFix(rangeCoAlgebra)
```

```scala
rangeFix(3)
// res28: FixedList = Fix(Some((3,Fix(Some((2,Fix(Some((1,Fix(None))))))))))
```

---

class: center, middle

# Generalised generalised folds!

---

```scala
val factorial: Int => Int =
  range andThen product
```

```scala
factorial(3)
// res29: Int = 6
```

---

```scala
val factorial: Int => Int =
  cata(productAlgebra, rangeCoAlgebra)
```

```scala
factorial(3)
// res30: Int = 6
```

---

class: center, middle

# Questions?

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

[@NicolasRinaudo]:https://twitter.com/NicolasRinaudo
[Besedo]:https://twitter.com/besedo_official

    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
          highlightStyle: 'github',
          highlightSpans: true,
          highlightLines: true
      });
    </script>
  </body>
</html>
